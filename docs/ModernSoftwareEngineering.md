# 모던 소프트웨어 엔지니어링 (Modern Software Engineering)

## 9장. 모듈성: 복잡성을 다루는 기본 원리

*  **TDD의 교훈: 테스트가 어렵다면 설계도 문제다**
    *  만약 작성한 코드에 대해 단위 테스트를 만들기가 힘들다면, 이는 모듈화가 부족하거나 결합도가 높다는 신호일 수 있습니다. 예를 들어 함수가 너무 많은 일을 하거나, 전역 상태에 의존하면 테스트하기 어렵습니다. TDD 관점에서 **"테스트하기 쉬운 설계가 좋은 설계"** 인 경우가 많습니다. 개발자들은 테스트 작성이 난해할 때 코드를 리팩토링하여 모듈 경계를 수정하고, 의존성을 분리하면서 설계를 개선합니다.
*  **TDD로 모듈성을 강화하자**
    *  TDD(Test-Driven Development)를 하면 자연스럽게 모듈 단위의 사고를 하게 됩니다. 테스트는 작은 단위(함수 또는 클래스)의 기능을 검증하므로, 코드를 그 단위로 쪼개 작성하게 됩니다. 결합도를 낮추고 의존성을 주입하는 과정에서 코드 구조가 더 모듈화됩니다.
*  **REST API로 모듈성을 강화하자**
    *  시스템을 서비스화하거나 분산시킬 때, RESTful API와 같은 명확한 통신 인터페이스를 활용하면 모듈성을 높일 수 있습니다. 거대한 애플리케이션을 마이크로서비스로 나누고 **엄격한 인터페이스(HTTP 요청/응답)** 를 통해 결합도를 낮추며, 플랫폼에 관계없이 모듈 간 협력이 가능해집니다.
*  **배포 파이프라인으로 모듈성을 강화하자**
    *  CI/CD 환경에서 모듈 단위로 빌드하고 배포할 수 있다면, 그 자체로 아키텍처 모듈성이 개선된 것입니다. 모듈별 파이프라인을 통해 한 모듈의 업데이트가 다른 부분에 영향 없이 사용자에게 전달될 수 있도록 느슨한 결합과 명확한 경계를 설계해야 합니다.
*  **모듈성의 규모는 크고 작음이 없다**
    *  모듈화 원칙은 대규모 엔터프라이즈 시스템부터 간단한 프로젝트까지 모두 유효합니다. 중요한 것은 규모에 관계없이 **"응집도 있게 묶고, 관련 없는 것은 분리한다"**는 기본 원칙을 지키는 것입니다.
*  **고성과 개발 조직의 특징: 모듈형**
    *  높은 성과를 내는 IT 조직은 제품과 조직 구조 모두 모듈화되어 있는 경우가 많습니다. **Conway의 법칙** 에 따라 조직의 경계가 소프트웨어의 모듈 경계가 되기도 합니다. 아마존이나 넷플릭스처럼 소규모 팀이 독립적으로 서비스를 책임지는 구조는 빠른 개선과 확장을 가능하게 합니다.
*  **정리**
    *  모듈성은 복잡한 문제를 다루는 기본 전략입니다. 모듈성이 높으면 수정 영향 범위가 적고 병렬 작업이 가능해져 개발을 스케일 업할 수 있습니다. 엔지니어의 핵심 역량은 어디까지 모듈로 뗄지 결정하는 균형 감각에 있습니다.

## 10장. 응집성: 소프트웨어의 관련 요소들은 한곳에

*  **모듈성과 응집성의 관계**
    *  **응집성(Cohesion)** 이란 모듈 내부 구성 요소들이 얼마나 밀접하게 관련되어 있는가를 나타냅니다. 이상적인 설계는 **"모듈 간에는 느슨하게(Low Coupling), 모듈 내부는 굳게(High Cohesion)"** 뭉쳐 있는 상태입니다.
*  **응집성 개선을 위한 리팩토링 사례**
    *  `UserManager`가 인증, 메일 발송, 포인트 계산을 모두 담당한다면 응집도가 낮습니다. 이를 각각 전담 클래스로 분리하면 이해하기 쉽고 변경 영향 범위가 제한됩니다. 리팩토링을 통해 응집도를 높이면 유지보수성이 극적으로 향상됩니다.
*  **DDD의 컨텍스트로 응집성 개선**
    *  도메인 주도 설계(DDD)의 **Bounded Context(경계 컨텍스트)** 개념은 응집도를 높이는 강력한 도구입니다. 주문, 결제, 배송 등 비즈니스 영역을 따라 시스템을 나누면 용어와 기능이 일관되게 유지되며 자연스럽게 고응집 구조가 형성됩니다.
*  **소프트웨어에서 '고성능'의 의미**
    *  소프트웨어에서 성능이란 처리 속도뿐 아니라 **변화에 대응하는 속도**도 포함합니다. 유연성의 뿌리에는 높은 응집도가 있으며, 이는 팀의 생산성 및 설계 품질과 직결됩니다.
*  **결합도와 응집성 사이의 관계**
    *  일반적으로 **높은 응집도(High Cohesion)** 를 유지하면 **낮은 결합도(Low Coupling)** 를 자연스럽게 얻게 됩니다. 연관된 기능을 한데 모으면 외부 모듈과의 불필요한 통신이 줄어들기 때문입니다.
*  **TDD로 응집성을 높이자**
    *  테스트는 응집도의 지표가 됩니다. 어떤 클래스를 테스트하기 위해 준비해야 할 객체가 너무 많다면 응집도가 낮다는 신호입니다. TDD는 이러한 설계를 감지하고 **단일 책임 원칙(SRP)** 에 맞게 개선하도록 가이드합니다.
*  **응집성 있는 소프트웨어를 만들려면**
    *  각 모듈이 하나의 **"액터(Actor)"** 처럼 행동하게 하고, 함수는 하나의 일만 하게 설계해야 합니다. 구체적인 네이밍을 사용하고 기능별/계층별로 코드를 조직화하는 것도 큰 도움이 됩니다.
*  **응집성이 부족할 때 치러야 할 대가**
    *  응집성이 낮은 시스템은 **"Big Ball of Mud(큰 진흙덩어리)"** 가 되어 작은 변경도 시스템 전체에 버그를 일으킵니다. 이는 기술 부채를 키우고 팀 생산성을 갉아먹는 주범이 됩니다.
*  **개발 조직 관점에서 응집성의 중요성**
    *  응집도가 높은 코드베이스는 업무 분담과 협업에 유리합니다. 모듈 경계가 명확하면 병렬 개발이 수월하고 새로운 팀원의 온보딩 시간도 단축됩니다.
*  **정리**
    *  응집성은 **"연관된 것은 함께, 관련 없는 것은 분리"**하는 원칙입니다. 이를 통해 이해하기 쉽고 변경에 강한 시스템을 만들 수 있습니다.

## 11장. 관심사 분리: 고품질 코드의 가장 중요한 속성

*  **의존성 주입(Dependency Injection)**
    *  **관심사 분리(SoC)** 를 구현하는 실용적 기법입니다. 클래스가 필요한 자원을 외부에서 주입받게 함으로써 "로직 수행"과 "자원 확보"라는 관심사를 분리하고, 테스트 용이성과 유연성을 확보합니다.
*  **본질적인 복잡성과 우발적인 복잡성**
    *  문제 자체의 어려움인 **본질적 복잡성** 은 피할 수 없지만, 구현 방식에서 오는 **우발적 복잡성** 은 줄여야 합니다. 관심사 분리는 핵심 로직에 집중하고 기술적 세부사항을 추상화하여 우발적 복잡성을 제어하는 활동입니다.
*  **DDD와 경계 컨텍스트**
    *  도메인별로 영역을 분리하여 각 컨텍스트 내의 언어와 모델에 집중하게 함으로써 팀 조직과 코드베이스를 효율적으로 관리할 수 있습니다.
*  **테스트하기 쉬운 코드 = 관심사가 분리된 코드**
    *  단일 책임 원칙(SRP)은 **테스타빌리티(Testability)** 와 직결됩니다. 복잡한 로직과 I/O를 분리하면 로직을 독립적으로 검증하기 쉬워지며, 이는 곧 좋은 설계로 이어집니다.
*  **육각형 아키텍처: 포트와 어댑터**
    *  비즈니스 로직(코어)과 외부 세계(I/O, DB, UI)를 철저히 분리합니다. **포트(인터페이스)** 와 **어댑터(구현체)** 를 통해 핵심 로직이 기술적 환경에 종속되지 않도록 보호합니다.
*  **포트와 어댑터의 채택 기준**
    *  변경 가능성이 높거나 입출력 채널이 다양한 프로젝트에서 특히 강력합니다. 다만 소규모 프로젝트에서는 **YAGNI** 원칙에 따라 적절한 수준의 구조를 선택해야 합니다.
*  **API 설계와 관심사 분리**
    *  API는 단순한 함수 호출 이상으로 버전 관리, 보안, 통신 프로토콜 등의 **부가 관심사** 를 포함합니다. 좋은 API는 이러한 세부를 캡슐화하여 클라이언트가 자신의 비즈니스 로직에만 집중하게 돕습니다.
*  **TDD를 이용한 상향식 관심사 분리**
    *  작은 단위부터 테스트하며 코드를 작성하다 보면 자연스럽게 역할이 겹치지 않는 모듈들이 만들어지며, 이를 조립하여 전체 시스템을 구축할 수 있습니다.
*  **정리**
    *  관심사 분리가 잘 된 시스템은 수정이 국부적이고 재사용이 용이합니다. 매 순간 **"코드가 여러 수준의 일을 섞어서 하고 있지 않은가?"**를 자문해야 합니다.

## 12장. 정보 은닉과 추상화: 우리의 적인가 친구인가

*  **정보 은닉과 추상화의 관계**
    *  **정보 은닉(Information Hiding)** 은 구현 상세를 숨기고, **추상화(Abstraction)** 는 핵심 개념을 드러냅니다. 둘은 복잡성을 줄이기 위한 단짝입니다.
*  **'큰 진흙탕(Big Ball of Mud)'의 원인**
    *  일정 압박, 무분별한 복사-붙여넣기, 혹은 지나친 오버엔지니어링(Over-engineering)이 원인이 됩니다. 적절한 정보 은닉과 추상화의 부재는 시스템 이해도를 떨어뜨립니다.
*  **테스트 코드를 통한 추상화 수준 결정**
    *  TDD를 통해 클라이언트 관점에서 인터페이스를 먼저 설계하면 필요한 추상화 수준을 효과적으로 정의할 수 있습니다.
*  **좋은 추상화의 역사**
    *  프로그래밍의 발전은 더 좋은 추상화(객체지향, 프레임워크, 클라우드 등)를 만들어온 역사입니다. 좋은 추상화는 개발자가 더 중요한 문제에 집중하게 해줍니다.
*  **구멍 난 추상화(Leaky Abstraction)**
    *  추상화 계층이 하위 상세를 완벽히 숨기지 못하고 드러나는 현상입니다. 이는 개발자에게 혼란을 주므로, 인터페이스 설계 시 내부 정보 유출을 경계해야 합니다.
*  **지형 지도와 노선도의 비유**
    *  추상화는 목적에 맞는 정보를 취사선택하는 과정입니다. 사용 목적에 따라 불필요한 상세는 과감히 생략하고 핵심 정보를 강조해야 합니다.
*  **이벤트 스토밍과 추상화**
    *  복잡한 비즈니스 로직을 **주요 이벤트** 흐름으로 추상화하여 시각화함으로써 팀 전체가 도메인을 이해하는 데 도움을 줍니다.
*  **우발적 복잡성으로서의 추상화**
    *  잘못되거나 과도한 추상화는 그 자체가 복잡성을 만듭니다. **KISS(Keep It Simple, Stupid)** 원칙에 따라 최소한의 추상화를 목표로 해야 합니다.
*  **외부 시스템 보호 계층**
    *  통제 불가능한 서드파티 코드를 직접 사용하지 말고, 우리 쪽의 안정적인 추상화 계층(어댑터)으로 감싸서 격리해야 합니다.
*  **정리**
    *  정보 은닉과 추상화는 복잡성을 길들이는 무기입니다. 변화에 유연하고 유지 가능한 구조를 만들기 위해 "필요한 것만 노출한다"는 원칙을 지켜야 합니다.

## 13장. 결합도: 소프트웨어 모듈 간의 상호 연관 수준

*  **결합도의 균형**
    *  **결합도(Coupling)** 가 낮을수록 좋지만, 극단적인 분리는 통신 오버헤드와 중복을 초래합니다. "각각 독립적이되 유기적으로 동작"하는 지점을 찾아야 합니다.
*  **과도하게 낮은 결합도의 문제**
    *  시스템이 너무 파편화되면 데이터 일관성 유지가 어렵고 전체 흐름을 파악하기 힘든 복잡성이 발생할 수 있습니다.
*  **긴밀한 결합의 폐해**
    *  변경 파급 효과가 크고 배포가 어려워지며 장애가 전파되기 쉽습니다. 이는 조직의 민첩성을 떨어뜨리는 주요 원인입니다.
*  **의도적인 결합과 수직 확장**
    *  성능이나 트랜잭션 일관성이 최우선인 경우, 의도적으로 결합도를 높여 속도를 확보하기도 합니다. 이는 명확한 트레이드오프 판단이 필요합니다.
*  **마이크로서비스(Microservices)**
    *  서비스 간 결합도를 낮추어 독립적인 배포와 운영을 가능하게 하는 패턴입니다. 팀별 자율성을 보장하고 신뢰성을 높여줍니다.
*  **느슨한 결합의 비용**
    *  결합도를 낮추기 위해 인프라 코드가 늘어나고 데이터 변환 등 추가 작업이 수반됩니다. 팀의 역량에 맞는 적정 수준의 분리가 중요합니다.
*  **결합도의 다양한 모델**
    *  **내용 결합(최악)**부터 **데이터 결합(최선)**까지 다양한 형태가 있습니다. 시간적 결합(Temporal Coupling)처럼 변경 시점이 연동되는 경우도 경계해야 합니다.
*  **DRY와 결합도의 충돌**
    *  중복을 없애려다 공통 라이브러리에 모두가 결합될 수 있습니다. 때로는 독립성을 위해 적절한 중복을 허용하는 결정이 필요합니다.
*  **비동기식 구현과 결합도 완화**
    *  이벤트 메시징을 활용하면 시간적 결합을 해소하고 시스템 간의 종속성을 줄여 확장성을 확보할 수 있습니다.
*  **DIP(의존성 역전 원칙)**
    *  상위 모듈이 하위 모듈 구현이 아닌 추상화에 의존하게 하여 결합도를 혁신적으로 낮춥니다.
*  **정리**
    *  결합도는 설계의 난이도를 좌우하는 지표입니다. 낮은 결합도를 통해 변화에 민첩하고 확장 가능한 시스템을 구축하는 것이 모던 엔지니어링의 목표입니다.

## 14장. 실제 사례로 되짚어 본 소프트웨어 공학

*  **공학의 진정한 가치**
    *  문제가 발생하지 않게 하는 안전망임과 동시에, 문제가 생겼을 때 효과적으로 대처하게 해주는 도구입니다.
*  **테스트 가능한 코드의 힘**
    *  단위 테스트가 촘촘한 모듈은 과감한 리팩토링과 요구사항 요구에 신속하게 대응할 수 있도록 해줍니다.
*  **관측 가능성(Observability)**
    *  "보이는 소프트웨어"를 만들어야 합니다. 모니터링과 로깅을 통해 데이터에 기반한 의사결정과 장애 대응을 수행해야 합니다.
*  **배포와 시스템의 완성**
    *  코드는 프로덕션에서 돌아갈 때 비로소 가치를 가집니다. **CI/CD**를 통해 배포를 자동화하고 일상적인 활동으로 만들어야 합니다.
*  **피드백의 속도**
    *  짧은 피드백 주기는 고속 학습 주기와 같습니다. 제품 품질과 사용자 만족도를 높이는 가장 확실한 길입니다.
*  **변수 통제와 운영 습관**
    *  장애 대응이나 성능 튜닝 시 한 번에 하나씩 변경하여 결과를 측정하는 공학적 습관이 복잡한 시스템 관리에 필수적입니다.
*  **지속적 개선(Continuous Improvement)**
    *  원칙을 머리로 아는 것을 넘어 팀과 시스템에 체화시켜 나가는 과정이 진정한 공학적 품질 향상을 가져옵니다.

## 15장. 모던 소프트웨어 엔지니어가 되려면

*  **조직과 시스템의 정렬**
    *  기술 구조뿐 아니라 조직 구조도 모듈화하고 **Conway의 법칙**을 활용해 협업 효율을 최적화해야 합니다.
*  **디지털 파괴(Digital Disruptive)**
    *  낡은 비효율을 깨고 새로운 기술과 자동화를 적극 채택하는 혁신적인 마인드가 필요합니다.
*  **결과와 메커니즘의 구분**
    *  프로세스 준수 자체가 목적이 되어서는 안 됩니다. 고객에게 가치를 전달하는 **결과(Outcome)** 에 집중해야 합니다.
*  **AI 시대의 공학 원리**
    *  머신러닝(ML) 시스템도 결국 소프트웨어입니다. 재현 가능한 실험, 모듈화, 피드백 루프 등 고전적 공학 원칙이 여전히 핵심입니다.
*  **핵심 아이디어 요약**
    *  **작게 나누고 빨리 돌려라**: 반복과 피드백.
    *  **근거 기반으로 결정하라**: 데이터와 측정.
    *  **복잡성을 적극적으로 다뤄라**: 모듈화와 추상화.
    *  **품질은 내재화된 것이다**: TDD, CI/CD.
    *  **끊임없이 배우고 개선하라**: 지속적 학습.
*  **마지막 한마디**
    *  모던 소프트웨어 엔지니어는 **과학자의 호기심, 엔지니어의 체계성, 장인의 열정**을 가진 사람입니다. "더 나은 소프트웨어를 더 빠르게(Better Software Faster)" 만들어 세상을 이롭게 하는 것이 우리의 궁극적 목표입니다.