모던 소프트웨어 엔지니어링

1부. 소프트웨어 엔지니어링이란 무엇인가

1장. 소프트웨어 공학의 정의와 역사
* **공학(Engineering)** 이란 인간의 실용적 문제를 과학적 지식으로 해결하는 것을 의미한다. 즉, 과학의 원리를 현실 문제에 적용하여 효율적이고 효과적인 해결책을 만들어내는 실천적 학문이다.
* **소프트웨어 공학(Software Engineering)** 은 소프트웨어 분야에 이러한 공학 개념을 적용한 것으로, 실증적이고 과학적인 접근법을 통해 경제적이고 실용적인 소프트웨어 문제 해결 방법을 찾는 활동을 말한다. 다시 말해, “최대한 적은 비용과 노력으로 높은 품질의 소프트웨어를 빠르게 개발하는 방법”을 추구하는 분야이다.
* 한때 소프트웨어 개발은 예술 또는 수공업처럼 여겨졌으나, 소프트웨어도 체계적 원리에 따라 개발해야 한다는 인식이 생기며 “소프트웨어 엔지니어링”이라는 용어가 등장했다. 이는 소프트웨어 개발을 반복 가능하고 예측 가능하게 만드는 방향으로 패러다임 전환이 일어났음을 의미한다.
* 소프트웨어 공학의 탄생: 1968년 독일 가르미슈에서 NATO 주관으로 열린 회의에서 처음으로 “소프트웨어 엔지니어링”이라는 용어가 공식적으로 사용되었다. 이 회의는 당시 만연하던 “소프트웨어 위기(Software Crisis)” – 즉, 소프트웨어를 제때에 예산 내에 품질 있게 완성하지 못하는 문제 – 를 해결하기 위해 학계와 업계 전문가들이 모인 역사적인 자리였다. 이 계기를 통해 소프트웨어 개발을 보다 체계적이고 학문적인 원칙에 따라 수행해야 한다는 공감대가 형성되었다.
* 이후 절차적 프로그래밍 → 구조적 방법론 → 객체지향 → Agile(애자일) 등으로 소프트웨어 개발 방법론에 여러 변화가 있었지만, 근본적인 목표는 복잡한 소프트웨어를 더 잘 만들기 위한 체계 확립이었다. 과거에는 완전히 새롭게 느껴지던 방법론들도 시간이 지나면서 공학적 지식으로 축적되었고, 소프트웨어 공학은 계속 진화하고 있다.
* 정리: 소프트웨어 공학은 **“과학적으로 사고하고 실용적으로 행동하여 소프트웨어 문제를 푸는 것”** 이다. 1960년대 말 소프트웨어 공학 개념이 탄생한 이후로, 소프트웨어 개발에는 개인의 재능뿐만 아니라 원칙과 프로세스가 중요하다는 인식이 자리잡았다. 이는 소프트웨어를 예술이나 수작업이 아닌, 체계적인 엔지니어링 활동으로 여겨야 더 나은 결과를 얻을 수 있다는 깨달음에서 출발한 것이다.

2장. 소프트웨어 ‘공학’의 참뜻
* “프로덕션(Production)은 우리의 문제가 아니다.” 소프트웨어는 한 번 만들어 놓으면 복제 비용이 거의 0에 가깝다. 제조업에서는 대량 생산(프로덕션)이 큰 도전이지만, 소프트웨어에서는 **핵심 난제는 생산(복제)이 아니라 처음 그것을 ‘어떻게 설계하고 구현하느냐’** 에 있다. 따라서 소프트웨어 공학에서 말하는 공학은 대량 생산 기술이 아닌, 올바른 설계와 구축 방법론에 대한 것이다.
* 코딩 = 공학? 꼭 그렇지 않다. 현업에서 흔히 소프트웨어 엔지니어라고 하면 코드를 잘 짜는 사람을 떠올리지만, 공학의 핵심은 단순 코딩 이상이다. 공학은 문제를 분석하고, 최적의 해결책을 설계하며, 그 결과를 검증하고 개선하는 전체적인 문제해결 과정을 포함한다 ￼. 따라서 코드 작성은 공학 활동의 일부일 뿐이며, 소프트웨어 공학 = 코딩만 잘하면 되는 것이 아니라는 점을 인지해야 한다.
* 수공예 vs 공학: 소프트웨어 개발 초기에는 장인정신에 의존한 ‘수공예’적 개발이 주류였다. 개별 개발자의 뛰어난 능력에 따라 품질이 좌우되고, 표준화된 절차나 도구보다는 경험과 노력에 기대는 형태였다. 반면 공학은 재현성과 확장성을 중시한다. 누구나 일정 수준 이상의 품질을 낼 수 있는 프로세스와 도구, 원칙을 마련하고자 한다. 다시 말해, 수공예가 장인의 손끝 기술에 의존한다면, 공학은 누가 작업해도 일정 품질 이상이 나오도록 하는 시스템에 의존한다.
* 물론 장인정신과 창의성도 소프트웨어 개발에 중요하다. 하지만 **수작업(장인 기술)** 만으로는 현대 대규모 소프트웨어의 복잡성을 감당하기 어렵다. 수공예 방식은 개인의 역량에 크게 의존하기 때문에 팀 규모가 커지거나 시스템이 복잡해지면 한계에 봉착한다. 반면 공학적 접근은 정밀한 측정과 반복 개선을 통해 규모가 커져도 통제 가능한 개발을 가능케 한다. 예를 들어, 성능이나 안정성을 수치로 모니터링하고 개선하는 것은 공학적 사고이며, 이러한 측정과 피드백이 없이는 복잡한 시스템 품질을 유지하기 어렵다.
* 우리가 하는 일이 왜 진정한 의미의 소프트웨어 공학이 아닐까? 현실에서는 많은 프로젝트가 체계적 원칙보다는 데드라인 압박에 쫓겨 즉흥적으로 진행된다. 그 결과 “대충 돌아가는 대충 만든 코드”가 양산되곤 한다. 이는 진정한 공학이라기보다, 급한 불 끄기 식의 응급조치 개발에 가깝다. 공학은 단기적인 편의보다 장기적인 품질과 효율을 추구하지만, 현실의 많은 개발 현장은 장인정신도 부족하고 공학적 엄밀함도 부족한 난장판(sloppy mess) 상태에 머물러 있는 경우가 많다.
* 소프트웨어 제작의 트레이드오프: 결합도가 핵심이다. 소프트웨어 설계에서는 변경 용이성 vs 즉각적 효율 사이의 줄다리기처럼 여러 트레이드오프가 존재한다. 그 중심에 결합도(coupling) 문제가 있다. 결합도가 높으면 컴포넌트 간 변경 영향이 커져 유연성이 떨어지지만, 반대로 너무 결합도를 떨어뜨리면 (예를 들어 모듈을 극도로 세분화하면) 시스템 전반의 관리 포인트가 늘어나 복잡도가 증가한다. 공학적 설계란 이러한 결합도를 적절히 관리하여 요구사항 변화에 잘 대응하면서도 지나친 복잡성을 억제하는 절충을 해 나가는 일이다. 이렇듯 소프트웨어 공학은 곧 복잡성 및 변경 관리의 예술이라고도 볼 수 있다.
* 기술 발전의 진보라는 환상에 빠지지 말아야 한다. 종종 “새로운 언어나 툴을 쓰면 생산성이 10배 좋아진다”는 식의 주장이 있지만, 전설적 공학자 프레드 브룩스는 1986년에 이미 “소프트웨어 개발에는 은탄환(silver bullet)은 존재하지 않는다”고 설파했다. 그는 **“향후 10년 내에 생산성, 신뢰성, 단순성을 10배 향상시킬 단일 기술이나 기법은 없다”** 고 단언하며, 하드웨어 분야의 무어의 법칙처럼 소프트웨어 생산성이 자동으로 비약적으로 향상되는 일은 없을 것이라 했다. 결국 새 기술도 근본적인 복잡성은 남기 마련이므로, 기초 원리(모듈화, 좋은 설계, 테스트 등)를 무시한 채 신기술만 쫓는 것은 환상이라는 점을 명심해야 한다.
* 수공예에서 공학으로의 여정은 아직 진행 중이다. 소프트웨어 분야는 비교적 역사도 짧고 변화도 빨라서, 전통 엔지니어링 만큼 표준화/체계화가 완성되어 있지 않다. 하지만 Agile 방법론이나 DevOps 같은 근대적 실천법들은 장인정신과 공학적 접근의 조화를 추구하며 한층 진화된 엔지니어링 문화를 만들어가고 있다. 더 이상 개인 영웅담에 기대지 않고, 팀과 조직의 지혜를 모아 소프트웨어 개발 프로세스를 지속 개선하는 방향으로 나아가는 것이 중요하다.
* 이제 우리가 고민해야 할 것은 “어떻게 하면 공학 원칙을 현실 프로젝트에 뿌리내리게 할까?”이다. 현대의 소프트웨어 엔지니어들은 새로운 언어나 프레임워크뿐만 아니라, 테스트 자동화, 지속적 통합, 모니터링, 코드리뷰, 리팩토링 문화 등 공학적 기법들을 일상 업무에 적용하는 데 힘써야 한다. 대학의 비전공자 1학년 학생들도 앞으로 소프트웨어를 다룰 때 이러한 공학 마인드셋 – 체계적으로 계획하고, 측정하고, 개선하는 사고방식 – 을 갖추는 것이 큰 자산이 될 것이다.
* 정리: 소프트웨어 ‘공학’이란 코딩 이상의 무엇이다. 이는 장인정신과 창의성을 존중하면서도, 체계적 원칙과 데이터에 기반한 의사결정으로 소프트웨어 개발을 수행하는 것을 뜻한다. 수공예적 접근의 한계를 인식하고, 측정과 반복을 통해 지속적으로 개선하는 자세가 현대 소프트웨어 공학의 참뜻이다. 다시 말해, **“대충 굴러가는 코드”를 넘어 과학적 엄밀함과 효율을 추구하는 것이 우리가 지향해야 할 모던 소프트웨어 엔지니어링의 길이다.

3장. 소프트웨어 공학을 이해하기 위한 기초 사항
* 새 기술만을 좇는 업계 풍토를 경계하자. 소프트웨어 분야는 유행 주기가 빨라 늘 새로운 언어, 프레임워크, 툴이 쏟아진다. 하지만 근본적인 원리는 비교적 변하지 않는다. 예컨대 1970년대의 모듈화 원칙이나 2000년대의 디자인 패턴 원리 등은 오늘날에도 여전히 유효하다. 최신 기술 자체보다 그 배경에 있는 공학적 문제 해결 원리를 배우는 것이 장기적으로 더 중요하다. 새로운 기술은 그때그때 활용하되, 핵심 개념(예: 높은 응집도, 낮은 결합도, 캡슐화 등)을 놓치지 말아야 한다.
* (비기능적 요소의) 측정의 중요성: “측정하지 않으면 개선할 수 없다”는 경영 격언이 있듯, 소프트웨어에서도 성능, 안정성, 보안, 사용성 등의 비기능적 품질을 숫자로 계량화해야 객관적으로 판단할 수 있다. 예를 들어 응답시간(ms), 장애복구시간(MTTR), 테스트 커버리지(%) 등의 지표를 살펴야 현재 상태를 정확히 파악하고 개선 목표를 설정할 수 있다. 이러한 품질 메트릭 없이는 문제를 감으로만 추정하게 되어 비효율적인 개발에 빠질 위험이 있다.
* 안정성과 처리량으로 생산성을 높이자: DevOps 연구 (DORA 등)에 따르면 소프트웨어 전달 속도(Throughput)와 안정성(Stability)은 트레이드오프가 아니라 동반상승하는 경향이 있다. 즉, 배포를 자주하고 빠르게 하는 팀일수록 서비스 안정성도 높다. 이는 빠른 피드백을 통해 결함을 조기에 잡고 지속적으로 개선한 결과이다. 반대로 “품질을 높이려면 개발을 느리게 한다”는 통념은 통계적으로 틀린 것으로 나타났다. 따라서 신속한 배포 파이프라인 구축과 자동화된 테스트로 안정성 확보를 동시에 추구하는 것이 현대 소프트웨어 공학의 생산성 비결이다.
* 우리는 어떤 분야의 전문가가 되어야 할까? 현대 소프트웨어 엔지니어는 특정 언어나 기술의 전문가라기보다, 학습과 적응의 전문가가 되어야 한다. 앞서 언급했듯 요구사항과 기술은 계속 변하기 때문에, 새로운 문제를 빠르게 이해하고 해결책을 찾아내는 능력이 중요하다. 마찬가지로 복잡성을 관리하는 전문가가 되는 것도 핵심 역량이다. 시스템이 커질수록 변경에 따른 영향 범위(코스트)가 기하급수적으로 늘어나는데, 이를 제어하지 못하면 개발 생산성은 급격히 떨어진다 ￼. 결국 좋은 엔지니어란 모르는 것을 금방 배우고, 복잡한 것을 단순하게 정리하는 사람이라고 할 수 있다.
* 학습의 전문가: 새로운 프레임워크든 도메인지식이든 학습 곡선을 빠르게 극복하고 자기 것으로 만드는 능력. 자신이 틀릴 수 있음을 인정하고 배우는 자세 ￼ ￼가 중요하다 (엔지니어링적 사고에서는 처음부터 완벽할 수 없고, 빠른 실험과 피드백으로 개선해나감).
* 복잡성 관리의 전문가: 의도적으로 모듈화를 잘하고 결합도를 낮추며, 자동화 도구를 활용해 사람이 일일이 할 일을 줄이는 능력. 복잡성 관리의 궁극적 목표는 변화에 유연한 시스템을 만드는 것이며, 이것이 곧 소프트웨어 품질의 핵심 척도이다 (변경에 쉽게 적응하면 고품질 소프트웨어라고 할 수 있음).
* 정리: 1부에서는 소프트웨어 엔지니어링의 개념과 배경을 살펴보았다. 요약하면, 모던 소프트웨어 엔지니어링은 과학적 사고(실험, 측정)를 바탕으로 소프트웨어 개발을 체계화하는 것이다. 새로운 기술을 쫓는 것에만 급급하기보다 변하지 않는 원리(효율적 학습, 복잡성 관리 등)를 익히는 것이 중요하다. 비전공자라 하더라도 소프트웨어 분야의 기본 개념과 원칙을 이해하면, 기술 변화에 흔들리지 않고 문제 해결에 집중하는 역량을 키울 수 있을 것이다.

2부. 소프트웨어 프로세스 개선을 위한 구체적인 실천 방안

4장. 개선을 위한 반복
* 반복(iteration)의 묘한 장점: 똑같은 작업이라도 여러 번 반복 수행하면 정확도와 이해도가 높아지는 효과가 있다. 예를 들어 코드를 한 번에 완벽하게 작성하려 하기보다는, 빠르게 초안을 만들고 고쳐 나가면 더 나은 결과가 나온다. 이러한 반복적인 작업 방식은 작은 실패를 수용하면서 점진적으로 개선할 기회를 제공한다. 한 사이클에서 잘못된 부분을 고치고 배우며, 다음 사이클에서는 더 나은 방향으로 나아갈 수 있다.
* 방어적인 설계 전략으로서의 반복: 처음부터 큰 실패를 하는 것보다, 작게 자주 실패하여 빠르게 교정하는 편이 리스크가 적다. 반복 개발을 하면 매 반복마다 시스템이 동작 가능한 상태이므로, 설령 결함이 있어도 금방 발견하고 수정할 수 있다. 이는 **“설계상의 실수를 완전히 없앨 순 없지만, 반복을 통해 그 영향을 최소화”** 하는 방어적 개발 전략이다. 실제로 짧은 이터레이션(Iteration)을 돌리는 팀일수록 버그가 생산 단계에 가기 전에 잡힐 확률이 높아 품질이 향상된다.
* “계획”이라는 유혹: 거대한 프로젝트일수록 초기 단계에 모든 것을 계획하고 싶은 유혹이 있다. 그러나 소프트웨어는 복잡하여 초기에 세운 계획대로 되지 않는 경우가 다반사다. 상세 계획을 오래 잡는 동안 요구사항이 바뀌거나, 개발하면서 기술적 어려움이 드러나기도 한다. 계획 수립 자체에 너무 많은 시간과 노력을 쓰면 변화에 대한 대응력이 떨어지며, 오히려 효율적이지 못하다. 완벽한 계획보다는, 적절한 계획 수립 후 빠르게 실행하여 피드백을 얻는 태도가 더 효과적이다.
* 반복 작업의 실제: 애자일 방법론 등에서는 1~2주 단위의 반복 개발(스프린트)을 권장한다. 이를 따르면 매 이터레이션마다 설계 → 구현 → 테스트 → 피드백이 이루어지므로, 계획과 실제의 차이를 즉각 알아차릴 수 있다. 예컨대 6개월 후를 예측하기보다 2주 후를 예측하는 쪽이 정확도가 높으며, 2주의 결과를 보고 다음 2주의 계획을 조정하면 된다. 이렇게 짧은 호흡으로 계획과 실행을 계속 조정하는 것이 현대적 프로세스 개선의 핵심이다.
* 정리: 반복은 변화를 수용하는 개발 방식이다. 한 번에 완벽을 기하기보다 조금 만들어보고, 피드백 받고, 개선하는 주기를 돌리면 결과적으로 더 나은 품질과 생산성을 얻는다. 이러한 반복적 접근은 개발팀이 불확실성을 관리하고, 고객 요구에 더 민첩하게 대응하도록 도와준다.

> 워터폴 vs 애자일: 전통적 워터폴(Waterfall) 모델은 개념/계획 → 설계 → 구현/배포 → 유지보수 단계를 순차적으로 거친다. 애자일(Agile) 혹은 반복적(Iterative) 개발은 작은 단위로 설계-구현-피드백 사이클을 여러 번 반복함으로써 점진적으로 시스템을 완성하는 과정을 보여준다. 두 접근법의 차이는 피드백 주기에 있다: 워터폴은 후반에 한 번의 큰 피드백(유저 테스트 등)이 있지만, 애자일은 짧은 주기의 지속적인 피드백을 통해 유연하게 방향을 수정한다.

5장. 피드백: 우수한 의사결정을 위한 필수 요소
* 피드백의 중요성을 보여주는 사례: 한 스타트업 팀 A와 팀 B가 동일한 제품을 개발했다고 가정하자. 팀 A는 6개월 동안 내부적으로 개발만 하고 나중에 한번에 출시했으며, 팀 B는 2주마다 사용자들에게 기능을 공개하고 의견을 받았다. 그 결과 팀 B는 시장 요구에 더 부합하는 제품을 만들었고 실패 가능성을 줄였다. 이 사례에서 보듯, 적절한 피드백을 주고받는 과정이 우수한 의사결정의 핵심이다. 피드백은 현실과 우리의 생각 사이의 격차를 메워 주므로, 이를 적극 활용하는 팀이 더 나은 결과를 낸다.
* 코딩 단계에서의 피드백: 가장 가까운 피드백은 코드 작성 즉시 받는 피드백이다. 예를 들어 코드를 작성하고 단위테스트를 돌리면, 코드가 의도대로 동작하는지 바로 알 수 있다. 또한 동료 프로그래머의 코드 리뷰도 중요한 피드백이다. 잘못된 구현이나 개선할 부분을 빨리 지적받으면, 버그를 사전에 제거하고 더 나은 코드를 얻을 수 있다. 이처럼 개발자 수준의 즉각적 피드백 루프(테스트 통과 여부, 코드 품질에 대한 동료 의견 등)는 결과물의 품질을 크게 끌어올린다.
* 통합 과정 피드백: 한 명의 개발자 작업이 끝이 아니라, 여러 구성원이 작성한 코드가 합쳐질 때 시스템 수준에서 문제가 없는지 확인하는 피드백이 필요하다. 지속적 통합(CI) 도구는 코드가 중앙 저장소에 커밋될 때마다 자동으로 빌드하고 테스트하여, 통합 과정에서 생기는 오류를 즉각 알려준다. 또한 QA(Test) 팀의 통합 테스트나 스테이징 환경에서의 시험 가동 등을 통해 모듈 사이의 호환성과 종합적인 기능 동작에 대한 피드백을 얻는다. 이러한 통합 단계의 피드백이 빠를수록, 부서 간에 “네 탓 내 탓” 하며 문제를 늦게 발견하는 일을 줄일 수 있다.
* 설계 단계 피드백: 설계에 대한 피드백은 구현 전에 받기 어렵지만, **동료와의 설계 검토(meeting)** 나 프로토타이핑을 통해 얻을 수 있다. 예를 들어 UML 다이어그램이나 아키텍처 스케치를 함께 보면서 토론하면, 혼자 놓쳤던 케이스를 동료가 짚어줄 수 있다. 또는 핵심 모듈에 대해 간단한 프로토타입을 먼저 만들어보면, 설계 구상 시에 예상 못한 문제가 드러날 수 있다. 설계 피드백을 미리 받으면 잘못된 방향으로 큰 시스템을 만드는 위험을 줄일 수 있다.
* 아키텍처 수준 피드백: 시스템 아키텍처(예: 마이크로서비스 vs 모놀리식 결정, 기술 스택 선택 등)는 바꾸기 어려우므로 초기 단계의 피드백이 특히 중요하다. 이때 **기술 검증(Proof of Concept)** 이나 **아키텍처 스파이크(spike)** 를 통해 핵심 가정을 테스트해볼 수 있다. 가령 새로운 데이터베이스가 요구 성능을 낼 수 있는지 작은 테스트를 해보거나, 한두 개 모듈만 분리 배포해보는 식이다. 또한 과거 유사 프로젝트의 사례를 조사하거나, 사내 아키텍트 리뷰를 받는 것도 좋은 피드백 방법이다. 아키텍처 피드백은 장기적으로 큰 비용 절감을 가져온다 – 잘못된 아키텍처를 초기에 수정하면 되지만, 나중에 바꾸려면 막대한 재작업이 필요하기 때문이다.
* 피드백은 빠를수록 좋다: 위에서 언급한 다양한 피드백 (코드, 통합, 설계, 아키텍처)은 시기와 빈도가 성공의 열쇠다. 피드백이 즉각적일수록 문제를 저렴한 시점에 고칠 수 있다. 예컨대 요구사항 오류를 운영 단계에서 고객에게 듣는다면 이미 늦었지만, 기획 단계에서 사용자 피드백을 받으면 방향 선회를 빨리 할 수 있다. **“빠른 피드백, 빠른 개선”** 이 우수한 팀과 평범한 팀을 가르는 기준이라고 해도 과언이 아니다.
* 제품 설계 피드백: 소프트웨어 엔지니어링은 코드에만 국한되지 않는다. UI/UX 디자인 시안에 대한 사용자 테스트, A/B 테스트 등을 통해 최종 사용자로부터 제품 자체에 대한 피드백을 얻어야 한다. 고객이 실제로 어떻게 쓰는지를 관찰하면, 우리가 중요하다고 여긴 기능이 사실은 안 쓰인다든가, 예상치 못한 사용 패턴을 발견할 수 있다. 이렇게 제품 설계 단계의 피드백을 통해 소프트웨어 엔지니어는 **단순히 “동작하는 소프트웨어”를 넘어 “사용자에게 유용한 소프트웨어”** 를 만들 수 있게 된다.
* 조직과 문화 차원의 피드백: 피드백 문화는 조직 전반에 스며들어야 한다. 예를 들어 정기적인 **회고 미팅(retrospective)** 을 통해 지난 개발 iteration에서 무엇이 좋았고 나빴는지 팀 차원에서 피드백을 주고받는다. 또한 개발 속도, 버그 발생률, 고객 만족도 등의 지표를 통해 프로세스 개선에 대한 피드백을 얻는다. 건강한 조직은 윗사람으로부터의 일방향 지시뿐 아니라 아래로부터의 현장 피드백이 자유롭다. 이런 문화적 피드백이 있을 때 엔지니어링 원칙들도 제대로 실행될 수 있다.
* 정리: 피드백 없이 하는 결정은 불확실성이 크다. 모던 소프트웨어 엔지니어링에서는 가능한 모든 단계에서 피드백을 수집하고 활용한다. 작은 코드 단위의 피드백부터 최종 사용자와 조직 운영에 이르기까지 다각도의 피드백 루프를 구축하면, 잘못된 길로 오래 가는 일이 줄어들고, 최적의 방향으로 의사결정을 지속 조정할 수 있다.

6장. 점진주의: 조금씩, 조금씩, 앞으로
* 우주선 예시로 보는 모듈성: 우주선을 설계할 때 한 번에 통째로 만들지 않고 모듈별로 나눠서 개발한다. 예를 들어 추진 로켓, 궤도선, 착륙선 등을 분리하고 개별 테스트한 후 조합한다. 소프트웨어도 마찬가지로, 시스템을 기능 모듈 단위로 쪼개서 부분 완성품을 만들어 나가며 전체를 구축할 수 있다. 이렇게 하면 각 모듈이 독립적으로 작동하도록 설계되어 변경이나 장애가 발생해도 전체 시스템에 미치는 영향을 최소화한다. 점진적 개발은 **모듈성(modularity)** 을 전제로 하며, 이는 앞서 언급한 복잡성 관리에도 유리하다.
* 효율 높은 조직 구성을 위한 비법: 점진주의를 조직에 적용하면 애자일한 조직 구조가 된다. 큰 팀 하나가 모든 걸 한꺼번에 하는 대신, 기능별 작은 팀들이 병렬로 조금씩 진행하는 것이다. 예를 들어 프론트엔드 팀, 백엔드 팀, 데이터베이스 팀이 따로 움직이기보다, **기능별 크로스기능 팀(feature team)** 을 구성해 해당 기능의 UI부터 DB까지 작은 vertical slice(수직적 분할)을 끝까지 구현하는 식이다. 이렇게 하면 각 팀이 작은 목표를 독립적으로 완수하고, 전체적으로는 병렬 개발로 속도가 빨라진다. 조직 자체를 모듈화한 셈이며, 이는 큰 조직의 복잡성을 줄이는 핵심 전략이다.
* 점진주의를 적용하기 위한 도구: 점진적으로 개발하려면 환경과 도구의 지원이 필요하다. **버전 관리 시스템(Git)** 은 여러 브랜치를 활용해 기능 단위를 병렬 개발하고 머지함으로써 점진적 통합을 돕는다. Feature Toggle(기능 토글) 기법은 코드는 배포하되 기능 활성화는 토글로 제어하여, 미완성 기능도 메인 코드베이스에 점진적으로 포함시킬 수 있게 해준다. CI/CD 파이프라인은 변경이 있을 때마다 자동으로 빌드/테스트/배포해 주어 점진적 릴리스(배포)를 가능하게 한다. 이러한 도구들은 모두 작은 단위의 변경을 빠르게 반영하기 위한 것으로, 점진주의를 현실에 적용하는 기반이라 할 수 있다.
* 변경의 부작용 최소화: 소프트웨어 수정 시 **부수효과(side effect)** 로 예기치 않은 부분이 망가지는 게 흔한 문제다. 점진주의는 한 번에 한 모듈이나 한 기능씩 변경하므로, 만약 문제가 생겨도 영향 범위가 작다. 또한 테스트 자동화를 갖춰두면 리팩토링이나 기능 추가 시 기존 기능이 망가지지 않았는지 즉각 확인할 수 있다. **분리된 아키텍처(예: 마이크로서비스)** 를 채택하면 한 서비스의 변경이 다른 서비스에 영향 주지 않도록 격리할 수도 있다. 핵심은 한 걸음 뗄 때마다 안전망(자동 테스트, 모니터링)을 두고 움직이는 것이다. 이렇게 하면 점진적 변경의 리스크가 통제 가능해진다.
* 점진적인 설계: 소프트웨어 설계도 점진적으로 할 수 있다. 이를 **진화적 설계(Evolutionary Design)** 라고 하는데, 초기에 모든 세부사항을 설계하기보다 현재 필요한 부분을 설계하고 구현하면서, 새로운 요구나 문제를 발견하면 설계를 개선해나가는 방식이다. TDD(Test-Driven Development) 같은 기법은 코드 구현 전에 테스트를 설계함으로써, 필요 최소한의 인터페이스와 기능을 정의하게 하고, 구현 후 리팩토링을 통해 설계를 다듬게 한다. 이런 식으로 필요에 따라 설계를 점차 구체화하면 YAGNI(You Ain’t Gonna Need It, “당장 필요하지 않은 것은 만들지 마라”) 원칙을 지킬 수 있고, **과설계(over-engineering)** 를 피하면서도 유연한 구조를 얻을 수 있다.
* 정리: 점진주의는 **“한 번에 모두”가 아니라 ** “조금씩, 그러나 끊임없이”**라는 접근이다. 이를 통해 개발 과정 내내 작동하는 소프트웨어를 유지하며, 필요할 때 언제든 방향 전환과 개선을 할 수 있다. 결과적으로 큰 덩어리를 나중에 통째로 검증하는 것이 아니라, 작은 덩어리들을 수시로 검증하고 통합하므로 위험을 줄이고 반응성을 높인다. 현대 소프트웨어 엔지니어링에서 점진주의는 빠른 가치 제공과 탄력적 대응을 위한 핵심 원리이다.

7장. 경험주의: 현실을 자각하자
* 꿈은 높게, 그러나 발은 땅에: 소프트웨어 프로젝트에서는 비전과 열정도 중요하지만, 현재 드러난 사실을 외면하면 안 된다. 아무리 멋진 아이디어도 실제로 구현 가능해야 의미가 있다. 경험주의란 **“현실 세계의 데이터와 경험을 바탕으로 의사결정”** 하는 태도를 뜻한다. 가령 “이 기능이 사용자에게 엄청나게 유용할 것이다”라고 가정만 하지 말고, 실제 사용자 행동 데이터를 관찰해야 한다. 높게 설정한 목표를 실현하려면 우선 현재 내가 어디에 서 있는지, 주변 환경은 어떤지 객관적으로 인식하는 것이 첫걸음이다.
* 실험과 실제 업무 경험은 구분해야 한다: 개발 과정에서는 종종 새로운 기술이나 방법을 실험적으로 시도해볼 수 있다. 그러나 중요한 마일스톤이나 프로덕션 릴리스에서는 확실히 검증된 것들 위주로 결정해야 한다. 경험주의적 조직은 **“실험실 모드”와 “실전 모드”** 를 구분짓는다. 예컨대 새로운 프레임워크 도입은 사이드 프로젝트나 시범 서비스로 먼저 해보고, 충분한 경험 데이터가 쌓이면 주요 프로젝트에 적용한다. 이렇게 하면 혁신과 안정 사이에서 균형을 잡을 수 있다.
* “저 이 버그 알아요!”의 함정: 간혹 디버깅 시에 비슷한 증상을 과거에 봤다는 이유로 문제를 단정 지어버리는 경우가 있다. “전에 메모리 누수 때문에 그랬으니 이번에도 틀림없이 그거야”라고 넘겨짚으면, 혹시 다른 원인일 경우 문제를 그르친다. 경험주의는 선입견보다 관찰을 중시하기에, 이전 경험이 있더라도 항상 새롭게 조사하고 검증하는 자세를 취한다. 실제로 같은 현상이라도 원인은 다양할 수 있으므로, 겸손하게 로그와 데이터를 확인하는 것이 옳다.
* 자기기만은 우리의 적: 사람은 보고 싶은 것만 보는 경향이 있다. 소프트웨어 개발에서도 자신이 선호하는 해법을 정당화하려고 데이터 해석을 왜곡하기 쉽다. 예를 들어 “이번 출시 기능, 사용자들이 분명 좋아할 거야”라는 믿음 때문에 부정적인 사용자 피드백을 무시한다면 이는 자기기만이다. 경험주의적인 엔지니어는 냉정하게 사실을 바라보고 불편한 진실도 받아들이는 용기를 가진다. 그래야만 올바른 조치를 취할 수 있기 때문이다.
* 우리의 주장에 맞는 현실을 발명하지 말자: 소프트웨어 프로젝트에서는 종종 정치적인 상황이나 압력 때문에 현실을 있는 그대로 기록하지 않고 미화하는 일이 벌어진다. (예: 진척률 50%인데도 “80% 완료”라고 보고하거나, 성능 지표가 나쁜데도 “문제 없다”고 치부함). 그러나 이런 식으로 가상의 낙관적 현실을 만들어내면 실제 문제 해결은 요원해진다. 경험주의 원칙은 **“사실대로 말하고, 사실대로 행동”** 하는 것이다. 불편한 데이터도 투명하게 드러내고, 그것을 출발점으로 개선해야 상황이 나아진다.
* 추측보다는 실험: 현실에 입각한 경험주의: 결국 모르면 실험을 통해 알아내는 것이 최선이다. 새로운 기능에 대한 사용자 반응이 궁금하면 일부 트래픽에만 노출(A/B 테스트)해보는 식이다. 성능 튜닝 아이디어가 있으면 작은 부하 테스트를 돌려 효과를 검증해본다. 이런 짧은 사이클의 실험을 생활화하면, 추측에 의존해 시행착오하는 시간을 줄일 수 있다. 경험주의란 의견이나 직감보다 현실에서 얻은 증거를 우선시하는 태도이며, 모던 소프트웨어 엔지니어에겐 필수적인 덕목이다.
* 정리: 경험주의는 **“사실에 기반해 배우고 결정한다”** 는 뜻이다. 소프트웨어 개발에서 이는 데이터와 실제 관찰을 통한 학습으로 구현된다. 주관적 확신이나 계획에 매몰되지 말고, 언제나 현실 세계(사용자, 시스템)의 목소리에 귀 기울이는 것이다. 그렇게 해야 예상과 다른 상황에도 유연하게 대응하고, 잘못된 길로 깊이 들어가지 않을 수 있다.

8장. 실험주의: 과학적 사고와 실천
* 물리학자 파인먼에게 배우는 ‘실험주의’: 리처드 파인먼은 “첫 번째 원칙은, 스스로를 속이지 말라. 그리고 당신은 속이기 가장 쉬운 사람이다”라고 말했다. 이는 소프트웨어 엔지니어링에도 통하는 말로, 자신의 아이디어가 옳다고 가정하지 말고 실제로 검증하라는 뜻이다. 실험주의란 말 그대로 과학 실험하듯 개발에 임하는 자세다. 가설을 세우고, 실험(코드나 테스트)으로 검증하고, 관찰된 결과로부터 결론을 내리는 과학적 방법론을 의미한다. 실험주의를 실천하기 위한 네 가지 핵심 원칙을 살펴보자:
	1.	피드백 – “결과를 빨리 확인하라”: 어떤 변경이나 시도를 했다면 그 효과를 바로 확인하는 체계를 갖춘다. 예를 들어 코드를 수정했다면 즉시 테스트를 돌려 결과(성공/실패)를 보고, 새로운 기능을 배포했다면 사용자 행동이나 모니터링 지표를 빨리 수집한다. 빠른 피드백은 실험의 생명이다 ￼. 피드백이 빨라야 실험을 자주 할 수 있고, 시행착오 속에서도 빠르게 옳은 방향을 찾아갈 수 있다.
	2.	가설 – “명확한 예측을 수립하라”: 실험주의에서는 무작정 해보기보다 **“이 변경을 하면 ~한 효과가 날 것이다”** 라는 구체적인 가설을 먼저 세운다. 그래야 결과가 나왔을 때 성공/실패를 판정할 수 있다. 예를 들어 “함수 알고리즘을 X로 바꾸면 처리속도가 20% 빨라질 것이다”라는 가설을 세운 뒤 코드를 수정해 측정한다. 이렇게 가설이 있으면 실험 결과를 해석하기 쉽고, 학습도 체계적으로 이루어진다.
	3.	측정 – “정확한 데이터를 모아라”: 실험 결과는 느낌이 아니라 데이터로 측정해야 한다. 인간은 주관적 편향이 있어서 원하는 방향으로 해석하기 쉽기 때문이다. 따라서 성능 개선 실험을 했다면 실제 처리량이나 응답시간 숫자를 수집하고, UI 변경 실험을 했다면 사용자 클릭률이나 이탈률 변화를 기록한다. 정량적 측정은 실험의 근본이며, 이러한 데이터 누적이 곧 지식 자산이 된다 ￼. 또한 측정은 반복 가능하고 정확해야 한다 – 동일 조건에서 같은 결과가 재현되는지 확인해야 실험의 신뢰성이 확보된다.
	4.	변수 통제 – “하나씩 바꿔라”: 과학 실험에서 한 번에 여러 변수를 바꾸면 어떤 변화가 결과에 영향을 주었는지 알 수 없듯이, 소프트웨어 실험에서도 한 번에 하나씩 변경하는 것이 원칙이다. 성능 개선을 한다고 코드도 바꾸고 DB도 바꾸면, 좋아져도 뭐 때문인지 모른다. TDD의 테스트도 마찬가지: 한 테스트는 한 가지 기능만 검증해야 무엇이 잘못됐는지 알 수 있다. 변수 통제는 실험에서 원인과 결과를 명확히 연결해 주기 때문에, 여러 개선안을 시도할 때는 순차적으로 하나씩 적용하고 평가하는 것이 바람직하다.
* TDD에서 배우는 자동화 테스트: 테스트 주도 개발(TDD)은 소프트웨어 분야에서 실험주의를 적용한 대표 사례다. 개발자는 코드를 작성하기 전에 기대되는 동작을 가설 삼아 테스트 케이스(실패할 상황)를 만들고 ￼, 그 테스트를 통과시키기 위해 코드를 작성한다. 빨간막대(실패) -> 초록막대(성공) -> 리팩터의 사이클은 곧 가설 -> 실험 -> 결과 분석의 사이클과 유사하다. TDD에서는 테스트가 일종의 실험 장치 역할을 하여, 새로운 코드를 추가할 때마다 자동으로 피드백을 제공해준다. 이는 개발자가 안전한 실험 환경에서 자유롭게 리팩토링(설계 개선)할 수 있게 해, 시스템 품질을 유지한 채로 진화를 거듭할 수 있게 한다.
* 테스트는 새로운 지식을 끌어내는 원천: 어떤 기능에 대해 테스트를 작성하다 보면, “만약 이 함수에 이상한 입력이 들어오면 어떻게 해야 하지?” 등 미처 생각지 못한 시나리오를 발견하게 된다. 이런 테스트 작성 과정은 곧 요구사항을 구체화하고 시스템에 대한 이해를 높이는 실험 과정이라고 볼 수 있다. 또한 테스트 결과는 개발자에게 시스템 동작에 대한 사실 기반의 피드백을 준다. 반복되는 테스트 실패는 설계의 문제점을 알려주고, 테스트 통과는 구현이 요구를 만족함을 증명한다. 이렇게 테스트를 통해 우리는 코드에 대한 새로운 지식을 계속 얻어나간다.
* 품질을 높이는 TDD 적용 사례: 예를 들어 한 팀이 복잡한 금융 계산 모듈을 개발할 때 TDD를 도입했다고 하자. 처음에는 개발 속도가 더딘 듯했지만, 시간이 지날수록 해당 모듈의 버그 발생률이 현저히 낮았고, 요구 변경에도 유연하게 대응했다. 왜냐하면 TDD로 촘촘한 테스트망을 갖춰둔 덕분에, 자신 있게 리팩토링하며 설계를 개선할 수 있었기 때문이다. 결과적으로 다른 모듈보다 유지보수 비용이 낮아지고 신뢰성이 높았다. 이 사례는 TDD라는 작은 실험주의적 실천이 장기적으로 제품 품질과 개발 효율을 모두 향상시킨 예이다.
* 정리: 실험주의는 소프트웨어 엔지니어링을 **경험적 학문(empirical discipline)** 으로 만들어준다 ￼. 추측이 아닌 증거, 독단이 아닌 재현 가능한 실험으로 방향을 잡는 것이다. 빠른 피드백, 명확한 가설, 정량적 측정, 변수 통제를 통해 개발을 하나의 과학 실험처럼 접근하면, 실패를 두려워하지 않고도 지속적으로 학습하고 개선할 수 있다. 이러한 실험 문화는 곧 더 나은 소프트웨어를 더 빠르게 만드는 모던 소프트웨어 엔지니어링의 밑거름이 된다.

3부. 소프트웨어 복잡성 관리를 위한 기본 원칙 5가지

9장. 모듈성: 분리와 재조합을 위한 기준
* 모듈성(Modularity)의 전형적 특징: 모듈성이란 큰 시스템을 작고 이해하기 쉬운 구성 요소(모듈)들로 분리하는 설계 철학이다. 이상적인 모듈은 자신의 기능을 독립적으로 수행하며, 잘 정의된 인터페이스를 통해서만 다른 모듈과 상호작용한다. 예를 들어 전자제품의 모듈화처럼, 소프트웨어에서도 UI, 비즈니스 로직, 데이터 접근 등을 분리하면 각각 교체나 수정이 쉬워진다. 모듈별로 개발과 테스트가 가능하기 때문에 전체 개발 속도와 품질이 향상된다.
* 설계는 언제나 중요하다: “코드 몇 줄이면 되는데 굳이 설계가 필요해?”라고 생각하기 쉽지만, 모든 소프트웨어에는 적절한 수준의 설계가 필요하다. 특히 모듈 경계를 어떻게 정할지는 시스템 성공의 관건이 된다. 설계를 전혀 안 할 수는 없으며, 모듈 간 관계를 제대로 정의하지 않으면 금방 스파게티 얽힌 구조가 되어버린다. 좋은 설계란 필요한 곳에 적절한 추상화와 분리를 적용하는 것이다. 초기 설계가 부족하면 나중에 구조적 문제를 해결하느라 더 큰 비용을 치른다. 반대로 초기부터 모듈 경계를 잘 설정해두면, 규모가 커져도 구조가 유지되어 복잡성을 제어할 수 있다.
* TDD의 교훈: 테스트가 어렵다면 설계도 문제다: 만약 작성한 코드에 대해 단위 테스트를 만들기가 힘들다면, 이는 모듈화가 부족하거나 결합도가 높다는 신호일 수 있다. 예를 들어 함수가 너무 많은 일을 하거나, 여기저기 전역 상태에 의존하면 테스트하기 어렵다. TDD 관점에서 **“테스트하기 쉬운 설계가 좋은 설계”** 인 경우가 많다. 실제로 개발자들은 테스트 작성이 난해할 때 코드를 리팩토링하여 모듈 경계를 수정하고, 의존성을 분리하면서 설계를 개선한다. 모듈성이 높고 응집된 코드일수록 테스트 작성이 쉽고, 이는 곧 그 설계가 건강함을 나타낸다.
* TDD로 모듈성을 강화하자: TDD(Test-Driven Development)를 하면 자연스럽게 모듈 단위의 사고를 하게 된다. 왜냐하면 테스트는 작은 단위(함수 또는 클래스)의 기능을 검증하므로, 코드를 그 단위로 쪼개 작성하게 된다. 또한 테스트 통과를 위해 결합도를 낮추고 의존성을 주입하는 등의 작업이 필요해지므로 결과적으로 코드 구조가 더 모듈화된다. 예를 들어, 어느 클래스가 I/O와 연산 로직을 모두 담고 있다면 TDD로 테스트하기 어렵기에, 로직 부분을 별도 모듈로 분리하는 식이다. 이렇게 테스트 친화적 개발 습관이 모듈성을 향상시킨다.
* REST API로 모듈성을 강화하자: 시스템을 서비스화하거나 분산시킬 때, RESTful API와 같은 명확한 통신 인터페이스를 활용하면 모듈성을 높일 수 있다. 하나의 거대한 애플리케이션을 여러 마이크로서비스로 나누고 REST API로 소통하게 하면, 각 서비스가 독립적인 모듈 역할을 한다. REST API는 **엄격한 인터페이스(HTTP 요청/응답)** 를 통해 결합도를 낮추며, 언어나 플랫폼이 달라도 모듈 간 협력이 가능하도록 해준다. 물론 모든 경우에 서비스를 나누는 것이 옳진 않지만, 시스템 경계를 API로 명확히 정의하는 것은 높은 모듈성을 얻는 효과적인 수단이다.
* 배포 파이프라인으로 모듈성을 강화하자: CI/CD 환경에서 모듈 단위로 빌드하고 배포할 수 있다면, 그 자체로 아키텍처 모듈성이 개선된 것이다. 예를 들어 독립적인 라이브러리나 서비스는 그 부분만 따로 배포 가능해야 한다. 모놀리식 시스템에서는 작은 변경도 전체를 재빌드/재배포해야 하므로 비효율적이다. 반면 모듈별 파이프라인이 있으면, 한 모듈 업데이트가 다른 부분에 영향 없이 바로 사용자에게 전달될 수 있다. 이런 모듈별 배포 독립성을 확보하려면, 사전에 코드 구조를 느슨히 결합시키고 경계를 명확히 설계해야 한다.
* 모듈성의 규모는 크고 작음이 없다: 모듈화 원칙은 거대한 엔터프라이즈 시스템부터 간단한 학년별 프로젝트까지 적용 범위에 상관없이 유효하다. 예를 들어 간단한 파이썬 프로그램이라도 파일별/클래스별 역할 구분을 명확히 하면 이해하기 쉬워진다. 반대로 대규모 시스템도 결국 모듈들의 집합이므로, 작은 모듈 하나하나가 건강해야 전체 시스템의 복잡성에 먹혀들지 않는다. 또한 모듈성은 코드뿐 아니라 하드웨어 구성, 팀 조직, 배포 패키지 구조 등 여러 차원에서 고려될 수 있다. 중요한 건 크기에 관계없이 “응집도 있게 묶고, 관련 없는 것은 분리한다”는 기본 원칙이다.
* 고성과 개발 조직의 특징: 모듈형: 업계 연구를 보면 높은 성과를 내는 IT조직은 제품 구조와 조직 구조 모두 모듈화되어 있는 경우가 많다. Conway의 법칙에 따라, 조직이 기능별로 나뉘어 협력하면 소프트웨어도 그 경계에 따라 모듈화된다. 아마존이나 넷플릭스 같은 기업은 소규모 팀들이 각기 서비스를 책임지는 마이크로서비스 + DevOps 모델을 활용해 빠른 개선과 확장을 이룬 것으로 유명하다. 이는 결국 모듈성 원칙을 조직 운영에까지 적용한 사례라 볼 수 있다. 이러한 구조에서는 한 팀이 자신의 모듈을 독립적으로 개발/배포하므로 전체 속도가 빨라지고, 문제도 국지화되어 복구가 신속하다.
* 정리: 모듈성은 복잡한 문제를 다루는 기본 전략이다. 분리할 것은 분리하고, 재조합할 때 명확한 계약에 따라 연결하는 것이다. 모듈성이 높으면 한 부분을 수정할 때 다른 부분에 미치는 영향이 적고 ￼, 여러 팀이 병렬로 작업할 수 있어 개발이 스케일 업된다. 다만 지나치게 잘게 나누면 관리 포인트가 늘어나는 만큼 적정 수준의 분리가 필요하다. 결국 경험을 통해 어디까지 모듈로 뗄지 결정하는 것이 엔지니어의 몫이며, 이는 앞으로 배울 다른 원칙들(응집도, 결합도 등)과 균형을 이뤄야 한다.

10장. 응집성: 소프트웨어의 관련 요소들은 한곳에
* 모듈성과 응집성의 관계: 응집성(cohesion)이란 모듈 내부 구성 요소들이 서로 얼마나 밀접하게 관련되어 있는가를 나타낸다. 높은 응집도란 한 모듈이 하나의 책임이나 기능에 집중하고 있음을 의미하며, 이는 곧 모듈성이 잘 설계되었음을 뜻한다. 모듈성은 시스템을 나누는 기준이고, 응집성은 나눈 각 조각의 내부 품질이다. 이상적인 설계에서는 모듈 간에는 느슨하게, 모듈 내부는 굳게 뭉쳐 있게 된다. 두 원칙 모두 중요하며, 보통 높은 응집도는 낮은 결합도와 함께 간다 (관련 기능을 한곳에 모으면 다른 부분과 상호작용이 줄어드므로).
* 응집성 개선을 위한 리팩토링 사례: 예를 들어 어떤 클래스 UserManager가 사용자 인증, 이메일 발송, 포인트 계산 등 여러 기능을 다 담당하고 있다면 응집도가 낮다. 이를 리팩토링하여 인증 전담 클래스, 메일 전담 클래스, 포인트 전담 클래스로 분리하면 각각의 응집도가 높아진다. 이 과정에서 UserManager는 실제로 인증/메일/포인트를 관리하는 여러 모듈을 조합하는 역할로 단순화된다. 결과적으로 각 모듈은 자신의 목적에 충실해져 이해하기 쉬워지고, 한 모듈의 변경이 다른 기능에 영향 주지 않게 된다. 이렇게 리팩토링으로 응집도를 높이면 유지보수성이 극적으로 향상된다.
* DDD의 컨텍스트로 응집성 개선: 도메인 주도 설계(DDD)에서는 Bounded Context(경계 컨텍스트) 개념으로 대규모 시스템을 여러 도메인 영역으로 나눈다. 예를 들어 전자상거래 시스템이라면 주문, 결제, 배송 등이 각각 별도 컨텍스트가 된다. 이는 해당 컨텍스트 내에서는 모든 관련 개념이 한 곳에 모이도록 해 응집도를 높이는 효과가 있다. 하나의 컨텍스트 안에서는 용어의 의미가 일관되고, 그 컨텍스트에 속한 기능들은 긴밀히 연관되어 동작한다. DDD를 따르면 도메인 경계를 따라 시스템이 모듈화되고, 각 부분의 응집도가 자연히 올라간다. 이는 비즈니스 개념 단위로 코드가 조직화되는 것이므로, 이해하기 쉽고 변경 영향 범위가 제한되는 장점이 있다.
* 소프트웨어에서 ‘고성능’의 의미: 물리 기계와 달리, 소프트웨어에서 성능 좋은(High-performance) 시스템이란 꼭 처리 속도만 의미하지는 않는다. 변화에 빠르게 대응할 수 있는 시스템도 일종의 고성능 시스템이라 할 수 있다 ￼. 이러한 유연성의 뿌리에는 높은 응집도와 낮은 결합도가 있다. 응집도가 높으면 특정 기능을 개선하거나 수정할 때 그 부분만 고려하면 되므로 개발 속도가 빠르다. 반면 응집도가 낮은 시스템은 한 기능 바꾸려다 엉뚱한 부분까지 영향이 미쳐서 수정에 오래 걸린다. 그러므로 소프트웨어의 성능(팀 생산성 관점에서)은 설계 품질, 특히 응집성과 결합도 같은 속성과 깊이 연관되어 있다.
* 결합도와 응집성 사이의 관계: 일반적으로 **높은 응집도(high cohesion)** 를 유지하면 **낮은 결합도(low coupling)** 를 자연스럽게 얻는 경우가 많다. 예컨데 한 모듈에 관련 기능을 몰아넣으면, 그 모듈이 다른 모듈과 통신해야 할 필요성이 줄어들기 때문이다. 반대로 응집도가 낮아서 이곳저곳 흩어진 기능들을 서로 호출하게 되면 모듈 간 결합도가 높아진다. 따라서 시스템을 설계할 때는 응집도와 결합도를 동시에 고려해야 한다. **“한 모듈의 내부는 단단히 뭉치고, 모듈 사이 연결은 최소화”** 가 최상의 시나리오이다. 이런 설계에서는 변경이 모듈 내부에서 흡수되고 외부로 파급되지 않으므로 유지보수가 쉬워진다.
* TDD로 응집성을 높이자: 앞서 TDD가 모듈화에 도움된다고 언급했듯이, 테스트는 응집도에도 지표 역할을 한다. 어떤 클래스를 단위테스트하려는데 준비해야 할 다른 객체가 너무 많다면, 그 클래스가 여러 역할을 섞어 수행하고 있을 확률이 높다. TDD를 통해 이런 부분을 감지하면, 자연스럽게 코드를 **SRP(단일 책임 원칙)** 에 맞게 리팩토링하게 된다. 예컨대 한 클래스에서 두 가지 일이 이루어진다면, 두 테스트 케이스를 작성해야 하고 이는 불편하니 클래스를 둘로 나누는 식이다. 이런 식으로 TDD는 코드의 응집도가 낮을 때 개발자로 하여금 냄새를 맡게 해주고, 개선 방향을 제시해준다.
* 응집성 있는 소프트웨어를 만들려면: 먼저 명확한 책임 분리 원칙을 세우고 코드를 작성해야 한다. 각 클래스나 모듈이 **“하나의 액터(actor)”** 처럼 행동하도록 설계하는 것이다. 함수도 마찬가지로, 가능한 한 하나의 일만 수행하도록 한다. 또 네이밍(이름짓기)을 응집도 판단에 활용할 수 있다. 만약 클래스 이름을 지었는데 “~Manager”처럼 포괄적인 이름이 된다면, 그 안에 여러 기능이 섞여 있을 확률이 있다. 차라리 좀 더 구체적인 이름을 지을 수 있도록 클래스를 쪼개보는 것이 좋다. 마지막으로, 코드 구조를 기능별/계층별로 폴더링하여 관련 파일끼리 모아주는 것도 응집도 향상에 도움 된다 (예: MVC 패턴에서는 Model, View, Controller 코드를 각각 디렉토리로 구분).
* 응집성이 부족할 때 치러야 할 대가: 낮은 응집도의 대표적 결과물이 “Big Ball of Mud”(큰 진흙덩어리) 아키텍처다. 여기서는 모든 것이 모든 것과 얽혀 있어, 작은 변경 하나도 시스템 곳곳에 예상치 못한 영향을 끼친다. 개발자는 특정 기능을 수정하려면 전혀 관련 없어 보이는 다른 부분까지 일일이 확인해야 하고, 버그는 수정하면 다른 곳에서 재발한다. 새로운 기능 추가 시 기존 코드와 뒤엉켜 복잡도가 기하급수적으로 증가한다. 이러한 상황에서는 개발 속도가 갈수록 느려지고, 품질은 떨어지며, 개발자도 지쳐 간다. 결국 시스템을 새로 만드는 것 외엔 답이 없다는 말까지 나오곤 한다. 응집성 부족은 기술 부채를 키우고 팀 생산성을 갉아먹는 주범이므로 초기부터 경계해야 한다.
* 개발 조직 관점에서 응집성의 중요성: 응집도가 높은 코드베이스는 팀의 업무 분담과 협업에도 유리하다. 예를 들어 모듈 A와 B가 잘 분리돼 있고 각각 응집도가 높다면, 팀원 한 명이 모듈 A를 전담하고 다른 한 명이 B를 맡아 병행 개발하기가 쉽다. 그러나 모듈 경계가 엉망이면 여러 사람이 동시에 같은 파일을 수정해야 하므로 충돌이 잦고 비효율적이다. 또한 응집도가 높으면 신입이나 다른 팀원이 특정 부분을 이해하는 데 걸리는 시간도 단축된다. “이 모듈은 X기능만 한다”고 명확히 말할 수 있으면 온보딩이 수월하다. 요컨대 응집성은 코드의 이해도와 협업 효율을 높여주는, 조직 생산성 측면에서도 중요한 속성이다.
* 정리: 응집성은 **“연관된 것은 함께, 관련 없는 것은 분리”** 라는 간단한 원칙이지만, 지키지 않으면 큰 혼란에 빠진다. 높은 응집도의 모듈은 이해하기 쉽고 변경 영향이 모듈 내부에 국한되며, 팀원 간 작업 충돌도 적다. 이를 달성하려면 책임을 단일화하고, 기능별로 코드 구조를 정리하는 노력이 필요하다. 결국 모듈성, 응집성, 결합도는 한 세트로 고려해야 하는데, 이중에서도 “한 곳에 모아놓을 것은 확실히 모아놓는 것”이 응집성의 요체다.

11장. 관심사 분리: 고품질 코드의 가장 중요한 속성
* 의존성 주입(Dependency Injection): 관심사 분리(SoC, Separation of Concerns)를 구현하는 실용적 기법 중 하나가 의존성 주입이다. 예를 들어 클래스 A가 클래스 B를 직접 생성해서 쓰는 대신, 외부에서 B의 인스턴스를 주입받게 하면 A와 B의 결합이 느슨해진다. 이는 A가 “자신의 로직”과 “필요한 외부자원 획득”이라는 두 관심사를 분리한 셈이다. DI를 활용하면 나중에 B를 교체하기도 쉽고, 특히 테스트 시에 가짜(Mock) 객체를 주입하여 A를 독립적으로 검증할 수 있다. 결과적으로 코드가 유연하고 테스트 용이해지며, 이는 유지보수성을 높여준다.
* 본질적인 복잡성과 우발적인 복잡성: 프레드 브룩스는 소프트웨어 복잡성을 본질적인(essential) 것과 부수적인(accidental) 것으로 구분했다. 본질적 복잡성은 해결하려는 문제 자체의 어려움에서 기인하며, 이것은 아무리 해도 없앨 수 없다. 반면 우발적 복잡성은 사용한 기술나 구현 방식 때문에 생긴 불필요한 복잡함이다. 예를 들어 비즈니스 로직 자체는 간단한데, 개발자가 언어 사용을 잘못해 메모리 관리 버그로 고생한다면 이는 우발적 복잡성이다. 관심사 분리란 곧 우발적 복잡성을 줄이는 활동이다. 핵심 문제(본질)에 집중하고, 부가적인 것들은 추상화나 자동화를 통해 단순화하는 것이 목표다. 이렇게 하면 개발자는 중요한 로직에 집중할 수 있고 전체 시스템 이해도도 높아진다.
* DDD는 중요하다: 경계 컨텍스트를 활용한 상향식 관심사 분리: 도메인 주도 설계(DDD)의 경계 컨텍스트(Bounded Context)는 관심사 분리의 한 형태다. 거대한 도메인을 context별로 분리하여, 각 컨텍스트 안에서는 그 분야의 언어와 모델에 집중하고, 다른 컨텍스트와는 명시적인 인터페이스(API)로 소통하게 한다. 이는 팀 조직과 코드베이스를 관심사(도메인 영역)별로 분할하는 효과가 있다. DDD 구현에서는 Context Map을 그려 컨텍스트 간 관계를 관리하는데, 이 역시 관심사들을 명확히 분리하고 통합하는 청사진이라 볼 수 있다. DDD를 제대로 적용하면, 비즈니스 로직, 인프라 구현, UI 등 서로 다른 관심사가 섞이지 않고 각자 맡은 역할에 충실한 시스템이 만들어진다.
* 테스트하기 쉬운 코드 = 관심사가 분리된 코드: 단일 책임 원칙(SRP)과 관심사 분리는 코드의 **테스타빌리티(testability)** 와 직결된다. 예를 들어 데이터베이스에 접속하여 계산도 하는 함수라면, 테스트하려면 DB 세팅이 필요해 복잡해진다. 이를 관심사별로 둘로 나누어 계산 로직은 순수 함수로 만들고, DB 접근은 별도 계층으로 분리하면, 계산 함수는 테스트가 간단해진다. 즉, 어떤 코드를 독립적으로 테스트할 수 있다는 것은 그 코드가 다른 것들과 적게 얽혀 있다는 증거다. 잘 설계된 모듈은 자신의 관심사만 다루기에, 외부 세계와의 접점을 모의(Mock)하거나 차단하여 검증할 수 있다. 그러므로 테스트가 쉽도록 코드를 구조화하다 보면 자연스럽게 관심사별 분리가 이뤄진다.
* 육각형 아키텍처: 포트와 어댑터: Hexagonal Architecture (허니콤 또는 육각형 아키텍처, Ports & Adapters 패턴)는 관심사 분리의 아키텍처적 접근이다. 핵심 아이디어는 애플리케이션을 안쪽 도메인 로직과 **바깥 세계(I/O)** 로 나누고, 이 둘을 포트(인터페이스)와 어댑터(구현체)를 통해 연결하는 것이다. 예를 들어 도메인 로직은 DB나 UI에 대해 전혀 모르며, 단지 “Repository”라는 인터페이스(포트)를 통해 데이터 접근을 한다. 실제 DB 연동은 Repository 인터페이스를 구현한 어댑터 클래스가 담당한다. 이 구조에서는 도메인(핵심 관심사)과 기술세부(부차 관심사)가 철저히 분리된다. 테스트 시에는 어댑터 대신 가짜 구현으로 대체할 수 있고, DB종류를 바꾸거나 UI를 웹에서 CLI로 바꿀 때도 도메인 로직은 손댈 필요가 없다. 결국 육각형 아키텍처는 코어 비즈니스 로직과 주변 기술 관심사를 깨끗이 분리하는 강력한 방법이다.
* 포트와 어댑터는 언제 채택해야 할까: 이상적으로는 모든 프로젝트에 좋은 아키텍처를 적용하면 좋겠지만, 현실적으로 작은 규모 앱에까지 복잡한 분리 구조를 만들 필요는 없다. 애플리케이션이 여러 종류의 입출력 채널을 가져야 하거나, 오래 유지보수되어 변경이 잦을 것으로 예상된다면 포트-어댑터 패턴을 고려해볼 만하다. 예컨대 동일한 도메인 로직을 두 가지 UI (웹/모바일)로 제공하거나, DB를 추후 교체할 여지가 있는 경우이다. 반면 단기간에 끝날 간단한 스크립트나 1인 개발 프로젝트라면, 너무 구조를 분리하면 개발 속도만 늦출 수 있다. 핵심은 변화의 가능성이 높은 부분을 사전에 추상화해두는 것이 관심사 분리의 목적이므로, 요구 변화나 시스템 확장 가능성을 판단해 적절한 수준으로 적용하면 된다.
* API가 단순한 함수 호출이 아닌 이유: 모듈 간 상호작용을 위해 **API(Application Programming Interface)** 를 설계할 때도 관심사 분리를 고려해야 한다. 예를 들어 클래스 내부 함수 호출은 같은 프로세스 내에서 즉각 일어나지만, 서비스 A의 API를 서비스 B가 호출하는 경우 네트워크 지연, 장애 대비, 호환성 유지 등 추가 관심사가 생긴다. API는 두 모듈(또는 시스템) 사이의 계약이므로 버전 관리, 오류 처리, 보안, 데이터 호환 등 신경 써야 할 부분이 많다. 따라서 단순히 함수를 노출하는 것과 API 제공은 차원이 다르다. API 설계시 이러한 **부가 관심사(통신 프로토콜, 인증 등)** 를 적절히 캡슐화하여, API 소비자는 내부 구현이나 통신 세부를 몰라도 자신의 로직에 집중할 수 있게 해야 한다. 좋은 API는 내부 복잡성을 숨기고 클라이언트가 자신의 관심사(비즈니스 로직)에만 집중하도록 돕는다.
* TDD를 이용한 상향식 관심사 분리: 관심사 분리는 큰 그림 아키텍처에서도 중요하지만, 실제 코딩 단계의 작은 선택에서도 실현된다. TDD 같은 bottom-up 접근으로 코드를 만들다 보면, 자연스럽게 느슨한 결합의 작은 단위 함수/클래스들이 만들어진다. 이후 이들을 조립하면서 전체 구조가 형성되는데, 이때 각 단위가 서로 역할이 겹치지 않고 깔끔히 분리되도록 유지하면 된다. 예를 들어 TDD로 특정 기능의 도메인 로직을 개발하고, 나중에 I/O 부분을 붙이는 식이면, 도메인 로직과 I/O가 섞이지 않은 구조가 된다. 이러한 상향식 방법은 처음부터 거대한 레이어 아키텍처를 계획하기 어려운 상황에서, 코드를 작성하면서 자연스럽게 관심사를 분리하는 효과를 준다.
* 정리: 관심사 분리는 코드의 구조화 원칙 중에서도 가장 핵심이라 할 수 있다. 이것이 잘 된 시스템은 이해하기 쉽고, 변경 시 국부적인 수정으로 충분하며, 재사용이 용이하다. 이를 실현하기 위해 의존성 주입, 계층화, 아키텍처 패턴 등 여러 기법을 활용할 수 있다. 중요한 점은 개발 단계마다 **“이 코드에 여러 가지 다른 수준의 일이 섞여 있지는 않은가?”** 를 자문하고, 가능하면 분리하는 것이다. 모던 소프트웨어 엔지니어링에선 작은 모듈 하나에도 관심사 분리를 적용하고, 나아가 팀과 서비스 수준에서도 이 원칙을 지켜 복잡성을 누그러뜨리는 디자인을 추구한다.

12장. 정보 은닉과 추상화: 우리의 적인가 친구인가
* 정보 은닉과 추상화는 한몸이다. 정보 은닉(information hiding)은 모듈 내부의 구현 상세를 외부에 숨기는 것이고, 추상화(abstraction)는 복잡한 현실에서 핵심 개념만 드러내는 것이다. 둘은 사실 뗄 수 없는 관계로, 어떤 것을 감추느냐에 따라 무엇이 드러나는지가 결정된다. 예를 들어 클래스 내부 구현(자료구조, 알고리즘)을 숨기고 메서드 시그니처만 노출하면, 사용자에게는 그 메서드 명세(추상화된 기능)만 보인다. 이런 식으로 불필요한 세부사항을 가려서 개념적인 단순함을 이끌어내는 것이 정보은닉+추상화의 콤비네이션이다. 잘만 활용하면 복잡성을 크게 줄여주는 친구 같은 존재지만, 반대로 잘못된 추상화는 문제를 더 꼬이게 하는 적이 될 수도 있다.
* ‘큰 진흙탕’(Big Ball of Mud)이 된 코드의 원인을 찾아서: 소프트웨어 아키텍처의 안티패턴인 Big Ball of Mud는 설계 원칙이 무시되고 모든 것이 얽힌 구조를 말한다. 이런 상태가 되는 원인은 다양하다:
* 조직적/문화적 문제: 일정 압박으로 빨리빨리 기능만 추가하고 정리는 못하는 문화, 개발자들이 공통된 설계 원칙 없이 각자 코딩하는 상황, 또는 아키텍트 부재 등이 해당된다. 이 경우 정보 은닉이나 추상화 원칙을 따를 시간적/심리적 여유가 없으니, 시스템이 무계획적으로 커진다.
* 기술적인 문제와 설계 부족: 처음에 작은 규모라 설계를 대충 했는데 폭발적으로 기능이 늘어난 경우, 초기의 단순구조가 누더기가 된다. 초반에 정보 은닉이나 모듈 경계 설정을 소홀히 하면, 나중에는 수정이 어려워져 억지로 이어붙인 코드가 양산된다. 또한 개발자들이 추상화보다는 복붙(copy-paste)에 의존하면 중복과 모순이 쌓여 코드가 진흙탕이 된다.
* 과도하게 공들인 공학의 우려: 한편으론 추상화를 지나치게 추구해 불필요한 복잡 계층을 만든 경우도 있다. 예를 들어 간단한 기능에도 디자인 패턴을 남발해 클래스가 수십 개가 되면, 정작 개발자는 핵심 로직을 따라가기 힘들어진다. 추상화를 잘못 적용하면 오히려 추상층과 현실 구현 간의 괴리가 커져 버그 찾기가 어려워질 수 있다. 이러한 over-engineering 역시 결국 시스템을 이해하기 어렵게 만들어 진흙탕을 초래한다.
* 추상화를 높이려면 테스트 코드부터 작성하라: 정보 은닉과 추상화 수준을 적절히 하려면 사용자 입장에서 생각하는 훈련이 필요하다. TDD를 하면 클라이언트 관점에서 API를 먼저 쓰게 되므로, 자연스럽게 “어떤 인터페이스가 편리할까?”를 고민하게 된다. 이는 필요한 추상화 수준을 결정하는 데 큰 도움을 준다. 예를 들어 어떤 객체를 사용할 때 테스트 코드에서 “이렇게 이렇게 호출하고 결과가 ~~ 나와야지”라고 쓰다 보면, 그 객체는 그런 동작을 추상적으로 제공해야 함을 알게 된다. 구현은 잠시 잊고 사용 시나리오에 맞춰 추상적인 인터페이스를 설계하면, 불필요한 세부 노출 없이도 충분히 기능을 쓸 수 있는 구조가 나온다. 이렇게 테스트 퍼스트 접근이 좋은 추상화의 가이드가 된다.
* 좋은 추상화가 핵심이다: 모든 프로그래밍의 진보는 더 좋은 추상화를 만들어온 역사라고 해도 과언이 아니다. 절차적 언어 -> 객체지향 -> 함수형, 혹은 어셈블리 -> 고급언어 -> 라이브러리/프레임워크 -> 클라우드 서비스에 이르기까지, **계속 반복되는 테마는 “개발자가 신경 써야 할 사항을 줄여주는 추상화”** 였다. 따라서 엔지니어는 현재 사용 중인 추상화들이 (언어, 프레임워크, 아키텍처 등) 제 역할을 잘 하고 있는지 늘 평가해야 한다. 좋은 추상화는 필요한 것만 보여주고 나머지는 완벽히 감춘다. 그 덕분에 우리는 세부사항에 정신 팔리지 않고 더 중요한 문제 해결에 집중할 수 있다. 이런 추상화의 힘 덕에 오늘날 복잡한 시스템도 쓸 수 있는 수준으로 관리되고 있는 것이다.
* 구멍 난 추상화(Leaky Abstraction): 문제는 모든 추상화가 완벽하지 않다는 데 있다. Joel Spolsky의 “Leaky Abstraction 법칙”에 따르면 “모든 비트 trivial(자명)하지 않은 추상화는 어느 정도 누수를 가진다”. 즉, 추상화 계층이 아래 상세를 완벽히 숨기지 못하고 일부 속성이 드러나버린다는 것이다. 예를 들어 ORMs(Object-Relational Mapping)은 DB SQL 쿼리의 복잡성을 추상화해주지만, 개발자는 결국 성능 이슈가 생기면 SQL 튜닝 같은 낮은 단계 지식을 알아야 한다. 이런 추상화의 누수는 개발자에게 혼란과 추가 학습 부담을 준다. 추상화가 원래 의도와 다르게 동작하면 디버깅이 어려워지고, 숨겨진 부분까지 이해해야 하므로 인지부하가 커진다. 따라서 추상화 층을 설계할 때 의도치 않은 내부 정보가 외부로 새어나오지 않도록 면밀히 검토해야 한다. 그리고 외부에 공개된 부분(API, 문서)에 대해서는 향후 구현이 바뀌어도 일관되게 유지해야 추상화의 신뢰성이 확보된다.
* 세계 지도와 지하철 노선도의 비유로 배우는 추상화 기법: 추상화란 목적에 맞게 정보를 취사선택하는 것이다. 세계 지도는 지형과 경계를 정확히 표현하지만, 지하철 노선도는 노선 연결관계에 집중하고 지리적 비율은 무시한다. 두 다이어그램 모두 현실의 추상화인데, 세계 지도는 여행자가 도시 간 거리를 가늠할 때 유용하고, 지하철 지도는 승객이 환승 경로를 파악하기에 유용하다. 소프트웨어도 마찬가지로, 사용 목적에 맞게 상세를 생략하거나 강조해야 한다. 예컨대 네트워크 토폴로지를 보여주는 다이어그램에서는 클래스 다이어그램 같은 세부는 생략하고 서비스 간 관계만 보여주는 식이다. 이러한 관점에서, 어떤 모듈의 인터페이스도 그 모듈을 사용하는 사람이 필요로 하는 기능만 드러내고 내부 구현은 감춘다. 결국 추상화는 지도를 그리는 작업과 같아서, 보는 사람이 필요한 정보에 집중할 수 있게 해주는 것이 핵심이다.
* 이벤트 스토밍으로 추상화를 달성하자: 이벤트 스토밍(Event Storming)은 DDD 문맥에서 쓰이는 도메인 모델링 기법으로, 도메인에서 일어나는 사건(event)을 추출해내어 전체 그림을 파악하는 워크숍 방식이다. 여기서 엔지니어와 도메인 전문가들은 부착식 메모지 등에 중요한 이벤트 (“주문 생성됨”, “결제 승인됨” 등)을 적어 시간 흐름에 따라 배치한다. 상세 구현은 전혀 언급되지 않고, 오직 도메인 **핵심 이벤트(업무 흐름의 추상화)** 들만 다룬다. 이 과정을 통해 팀은 복잡한 비즈니스 로직을 추상화된 이벤트 흐름으로 이해하게 된다. 나아가, 이러한 이벤트들을 기준으로 Bounded Context를 나누거나 서비스 경계를 설정하기도 한다. 이벤트 스토밍은 추상화를 단체로 수행하는 예라 할 수 있으며, 개발 초기 아이디어 수집 및 모델 도출에 큰 도움이 된다.
* 추상화된 우발적인 복잡성: 재밌는 모순처럼 들리지만, 잘못된 추상화는 그것 자체가 부수적인 복잡성을 만들어낸다. 예를 들어 지나치게 일반화된 프레임워크를 도입했는데 우리 프로젝트엔 오히려 복잡도만 더해주는 경우다. 또는 간단한 기능을 추상화 계층 여러 개를 통해 호출하도록 설계하면, 계층간 전달로 프로세스가 복잡해진다. 이처럼 필요 이상의 추상화는 개발을 어렵게 한다. 우발적 복잡성을 줄이려다 도리어 늘려버린 셈이다. 그러므로 추상화 수준은 요구에 딱 맞게, KISS(Keep It Simple, Stupid) 원칙에 따라 최소한으로 설정하는 게 중요하다. 추상화는 강력한 도구지만 남용하면 해가 될 수 있음을 항상 경계해야 한다.
* 타사 시스템과 타사 코드를 격리하자: 현실적으로 완전히 우리의 통제 하에 있지 않은 코드나 시스템을 사용해야 할 때가 많다 (서드파티 라이브러리, 외부 API 등). 이때는 안정적인 추상화 계층을 우리 쪽에 만들어 외부 것을 감싸는 것이 좋다. 예를 들어 특정 서드파티 결제 시스템을 호출하는 코드를 여기저기서 직접 쓰지 말고, PaymentService라는 추상 인터페이스와 PaymentServiceImpl 어댑터를 한 곳에 만들어 놓고 사용한다. 이렇게 하면 나중에 서드파티가 변경되어도 그 어댑터만 수정하면 되고, 다른 코드들은 영향을 받지 않는다. 또한 외부 API 특유의 에러 처리나 데이터 형식도 우리 쪽 표준으로 변환해주면, 내부 로직은 일관된 추상화로 개발할 수 있어 편해진다. 요컨대 외부 요소로 인한 복잡성은 경계면에서 격리해두어야 우리 시스템 전체의 복잡도를 낮출 수 있다.
* 추상화와 구상화 사이의 트레이드오프: 모든 것을 추상화하면 현실과 동떨어진 모델이 되고, 반대로 너무 구체적이면 범용성이 떨어진다. 이 균형을 맞추는 것이 엔지니어의 예술이다. 추상화 수준을 결정할 때는 YAGNI (필요 없을 것 같으면 넣지 마라) 원칙이 도움이 된다. 너무 미래까지 대비한 일반화는 불필요할 수 있으니, 현재 문제를 충분히 깨끗하게 해결할 정도까지만 추상화하는 것이 좋다. 그리고 구체 구현은 추상화 뒤에 숨기되 완전히 감추지 말고 문서화 등을 통해 “어떤 일이 벌어지는지” 힌트를 남겨두는 것도 필요하다 (특히 성능이나 중요한 부작용 관련). 이러한 세심한 접근이 추상화의 이점(단순성 유지)과 구체성의 이점(실제 동작 통제)을 모두 챙길 수 있게 해준다.
* 정리: 정보 은닉과 추상화는 복잡성을 길들이는 무기다. 둘을 현명하게 활용하면 개발자는 꼭 필요한 사항에 집중하고 나머지는 신경 쓰지 않아도 되며, 시스템 변경도 국지적으로 일어난다. 그러나 잘못된 추상화는 오히려 혼란과 오류를 낳을 수 있으므로, 적정 수준의 추상화를 목표로 해야 한다. 모던 소프트웨어 엔지니어링에서는 “필요한 것만 노출하고, 나머지는 숨긴다”는 원칙 아래, 객체 지향의 캡슐화, 모듈 간 인터페이스, 계층 아키텍처, API 설계 등을 신중하게 다룬다. 이는 궁극적으로 대규모 복잡한 시스템도 이해 가능하고 유지 가능한 구조로 만드는 토대가 된다.

13장. 결합도: 소프트웨어 모듈 간의 상호 연관 수준
* 너무 느슨해도 너무 긴밀해도 문제: 결합도(coupling)는 한 모듈이 다른 모듈에 얼마나 의존하고 연결되었는지를 나타낸다. **긴밀한 결합(tight coupling)** 은 모듈들이 떼려야 뗄 수 없을 정도로 밀접한 상태로, 한쪽 변경 시 다른 쪽도 변경해야 하는 상황이다. 반대로 **느슨한 결합(loose coupling)** 은 모듈들이 최소한의 연결만 유지하는 상태다. 이상적으로는 결합도가 낮을수록 좋지만, 너무 지나치게 분리하면 모듈 간 의사소통 비용이 커지고 중복이 늘어날 수 있다. 예를 들어 서비스를 극단적으로 쪼개면 API 통신 오버헤드가 증가하고 관리 포인트도 많아진다. 따라서 결합도는 낮추되, 필요한 곳에서는 일정 수준 유지라는 균형점이 존재한다. *“각각 독립적이지만 함께 유기적으로 동작”*하는 상태를 목표로 해야 한다.
* 너무 느슨한 결합의 사례: 만약 시스템을 구성하는 컴포넌트들이 서로 거의 상호작용하지 않는다면, 기능 구현에 중복이 많아지거나 일관성 유지가 어려워질 수 있다. 예를 들어 데이터 일관성을 유지해야 하는 두 모듈이 너무 분리돼서 각각 별도 DB를 쓰며 소통이 없다면, 같은 데이터가 두 곳에 존재해 동기화 문제가 생길 수 있다. 또한 한 기능을 위해 여러 모듈이 연쇄 호출을 해야 할 때 인터페이스가 지나치게 추상적이면, 개발자가 전체 흐름 파악이 어렵고 디버깅도 힘들어진다. 이처럼 필요 이상으로 결합도를 낮추면 오히려 시스템 복잡성이 다른 형태로 증가한다 (ex: 더 많은 코드와 설정이 필요 ￼). 따라서 업무적으로 강한 연관이 있는 부분은 적절히 모아두는 편이 낫다.
* 너무 긴밀한 결합의 폐해: 앞서 여러 번 다룬 대로, 모듈 간 결합도가 높으면 변경 파급이 커서 개발이 어려워진다. 한 모듈을 수정하려면 연관된 여러 모듈을 다 고쳐야 하고, 인터페이스 하나 바꾸면 사용하는 모든 곳을 업데이트해야 한다. 특히 거대한 모놀리식(monolithic) 애플리케이션은 구성 요소 간 결합도가 높기 쉬운데, 여기서는 배포도 전체를 한 번에 해야 하고, 한 부분 장애가 전체 시스템을 마비시킬 수도 있다. 또한 새로운 기술 도입이나 확장이 어려워 조직이 민첩성을 잃는다. 큰 조직일수록 이 강한 결합의 덫에 빠지면, 변화에 매우 둔감하고 유지보수 인력/시간이 기하급수적으로 필요해진다. 이는 궁극적으로 엔지니어링 생산성의 심각한 저하로 이어진다.
* 수직 확장을 위해서는 결합도가 필수: 결합도도 완전히 나쁜 것은 아니다. 때로는 성능이나 통합 관리상의 이유로 일부러 결합도를 높이는 결정도 필요하다. 예를 들어 실시간 고성능이 요구되는 시스템에서는 함수 호출이나 메모리 공유를 통해 직접 결합된 통신을 사용하고, 이는 속도를 높여준다. 분산 시스템보다 하나의 프로세스 내에서 동작하도록 구성하면 레이턴시가 낮아지는 식이다. 또 다른 예로, 강한 트랜잭션 일관성이 필요하면 모듈들을 하나의 데이터베이스에 묶어 ACID 특성을 이용할 수 있다. 이처럼 제품 목표(고성능, 일관성 등)에 따라 일부 영역은 의도적으로 결합시키기도 한다. 이러한 수직적 통합은 성능은 좋지만 유연성이 희생되므로, 핵심 경로 외에는 남용하지 말아야 한다.
* 마이크로서비스: 결합도를 분리하기 위한 효과적인 방법: 최근 소프트웨어 아키텍처의 대세 중 하나는 **마이크로서비스(microservices)** 이다. 이는 시스템을 작고 자족적인 서비스들로 분할하고, 각 서비스가 독립적으로 배포/운영되도록 하는 패턴이다. 마이크로서비스의 주요 목표는 서비스 간 결합도를 낮추는 것이다. 예를 들어 한 서비스가 다른 서비스 DB에 직접 접근하지 않고, 반드시 API를 통해 통신하도록 강제한다. 서비스들은 각자 독립된 기술 스택을 써도 되고, 장애가 나도 다른 서비스에 영향을 덜 준다. Netflix나 Amazon 등의 사례에서, 마이크로서비스로 전환하여 개발 팀별로 서비스를 맡아 결합도를 조직 단위로 분산시켰고, 그 결과 배포 속도와 신뢰성이 크게 향상되었다고 알려져 있다 ￼. 마이크로서비스는 결합도 완화를 극한까지 적용한 사례이며, 성공적으로 구현하면 대규모 시스템도 작은 서비스들의 모음으로 이해하고 관리할 수 있게 된다.
* 느슨한 결합도의 대가: 더 크고 많아진 코드: 마이크로서비스 같은 접근에는 트레이드오프가 있다. 모듈 간 결합도를 낮추면, 모듈 간 연결을 위한 추가 코드가 많이 필요해진다. 네트워크 호출, 데이터 변환, 에러 재시도 등의 인프라 코드가 증가하고, 각 서비스마다 중복되는 유틸리티나 모델이 생길 수 있다. 또 데이터가 분산되면 중앙에서 한번 처리할 것을 각 서비스에서 중복 처리해야 하는 경우도 있다. 요컨대, 느슨한 결합을 이루는 대가로 시스템 전체 코드량과 복잡도는 어느 정도 증가한다. 이는 자동화 및 관리 도구의 힘으로 완화할 수 있지만, 너무 많은 서비스는 오히려 개발자에게 부담이 될 수 있다. 따라서 팀 규모와 능력에 맞게 적정 수준으로 분리하는 것이 중요하다.
* 결합도 모델은 한 종류만이 아니다: 결합도에는 여러 유형이 있다. 예를 들어 내용 결합(content coupling): 한 모듈이 직접 다른 모듈 내부를 건드는 최악의 결합(전역 변수 공유 등), 제어 결합(control coupling): 모듈 A가 모듈 B의 동작을 제어하기 위해 플래그 등을 전달하는 것, 데이터 결합(data coupling): 모듈 간 순수한 데이터만 교환하는 가장 낮은 형태의 결합 등으로 분류한다. 또한 시간적 결합(temporal coupling) 같은 개념도 있는데, 이는 “두 기능이 항상 동시에 수정되어야 한다”처럼 변경 시점이 연동되는 관계를 뜻한다. 이런 다양한 결합 형태를 인지하면, 단순히 결합도 수치만 볼 게 아니라 무슨 종류의 결합이 문제인지 파악할 수 있다. 예컨대 내용 결합은 즉시 개선해야 하지만, 데이터 결합은 허용된다. 이런 식으로 결합도를 세분화해 진단하면 더 정교한 설계 개선이 가능하다.
* 어쨌든, 느슨한 결합이 긴밀한 결합보다는 좋다: 이상적인 소프트웨어는 부품처럼 서로 독립적이면서 필요할 때만 소통하는 구조다. 현실적으로 100% 독립은 불가능하지만, 대부분 시스템에서 아직 불필요하게 엉켜있는 부분이 있기 마련이다. 예를 들어 UI 코드가 비즈니스 로직과 섞여 있다든지, 서비스 간에 중복 기능을 라이브러리로 공유하느라 강하게 결합되어 있다든지 하는 경우다. 이러한 부분을 찾아 약한 연결고리로 변경하면 많은 이점이 발생한다. 코드 변경 영향 범위가 줄고, 새로운 요구사항에 유연해지며, 성능이 조금 희생되더라도 유지보수 용이성이 높아진다. 특히 현대의 클라우드/분산 환경에서는 느슨한 결합 아키텍처가 확장성(scalability)과 지속적인 배포를 가능하게 해준다. 결합도를 완화하는 일은 초기에는 추가작업처럼 보여도, 장기적으로 비용을 아끼는 투자인 경우가 많다.
* 느슨한 결합과 관심사 분리의 상관관계: 관심사 분리는 결합도와 응집도 개념을 포괄하는 상위 원칙이다. 자연스럽게 관심사가 잘 분리된 시스템은 모듈 간 결합도가 낮을 수밖에 없다, 왜냐하면 각 관심사가 독립 모듈로 존재하니까. 예를 들어 UI와 로직을 MVC 패턴으로 분리하면, UI 모듈과 로직 모듈은 명확한 인터페이스(모델)로 소통하며 결합도가 낮아진다. 반대로 한 화면 클래스에 UI와 데이터처리 로직이 다 들어있다면, 그 화면과 다른 부분은 긴밀히 얽힐 것이다. 그러므로 결합도를 낮추고 싶다면 먼저 관심사 분리를 점검해야 한다. 한 모듈이 여러 관심사를 다루고 있다면 응집도를 높이고 결합도를 낮추는 리팩토링 기회를 찾은 것이다.
* DRY는 너무 단순하다: “Don’t Repeat Yourself”(코드 중복을 피하라)는 좋은 개발 원칙이지만, 결합도 관점에서 맹목적으로 따를 일은 아니다. 중복을 없애기 위해 모든 곳에서 공통으로 쓰는 유틸을 만들면, 그 유틸에 모든 곳이 결합된다. 변경 시 파급효과가 커지는 것이다. 그래서 마이크로서비스 설계에서는 의도적인 중복 허용이 나온다 – 서비스 간 코드를 공유 라이브러리로 뽑지 않고 각각 복사해서 갖도록 하는 것이다. 언뜻 비효율 같지만, 이렇게 하면 서비스들이 서로 독립적이어서 결합도가 내려간다. DRY 원칙만 추구하다 보면 오히려 결합도가 높아질 수 있으므로, 적절한 중복은 감수하고 모듈 독립성을 지키는 편이 좋다. 요컨대 실무에서는 “중복을 줄여 유지보수성 향상” vs “결합도 감소로 서비스 독립성 향상” 사이에서 균형 잡기가 필요하며, 경우에 따라 DRY보다 모듈 격리를 우선시해야 할 때가 있다.
* 느슨한 결합을 위한 비동기식 구현 방법: 시스템 간 결합도를 낮추는 방법으로 비동기 메시징/이벤트 기반 아키텍처가 널리 쓰인다. 동기 방식(API 호출 등)은 호출자가 응답을 기다려야 해서 서로의 가용성에 영향을 받지만, 비동기 큐나 Pub/Sub를 사용하면 한 시스템이 메시지를 보내놓고 바로 다음 일을 할 수 있고, 수신 시스템은 자신의 페이스대로 처리한다. 이는 시간적 결합(temporal coupling)을 완화시킨다. 예를 들어 주문 시스템이 결제 시스템을 동기 호출하면 결제가 느릴 때 주문 흐름이 막히지만, 메시지 큐에 “주문 발생” 이벤트를 발행하면 결제 서비스는 알아서 처리하고 오류나 완료 상태만 나중에 업데이트하면 된다. 이러한 이벤트 중심 설계는 서비스들 간 느슨한 연결과 확장성을 제공하며, 새로운 서비스가 이벤트만 구독하면 기능 추가도 쉬워지는 효과가 있다.
* 느슨한 결합을 위한 설계: 인터페이스와 추상화를 활용해 **의존성 방향을 역전(DIP 원칙)** 시키면 결합도를 크게 줄일 수 있다. 예를 들어 상위 모듈이 하위 모듈 구현에 직접 의존하지 않고, 추상 인터페이스에 의존하게 만드는 것이다. (하위 모듈이 그 인터페이스 구현체를 제공). 이러면 상위-하위 모듈 간 결합이 추상 인터페이스 하나로 약화된다. 또 다른 디자인 원칙은 팩토리 패턴이나 이벤트 디스패처 등을 써서 모듈 간 직접 호출을 줄이는 것이다. 콜백이나 이벤트 핸들러는 느슨한 연결을 가능케 하는 도구다. 그리고 표준 프로토콜 활용도 중요하다. 예를 들어 파일 저장 모듈을 로컬이든 클라우드든 POSIX 파일 I/O 인터페이스로 추상화하면, 나중에 구현 바뀌어도 호출부는 영향이 없다. 이처럼 설계 단계에서부터 모듈 간 계약을 잘 정의하면, 각 모듈은 계약만 지키면 되므로 서로 내부에 무슨 일이 있는지 몰라도 되는 관계가 된다.
* 강건한 결합도로 영원히 고통받는 대규모 조직: 흔히 전통적 대기업들의 레거시 시스템이 이런 상태에 놓여 있다. 수십 년에 걸쳐 개발된 거대한 모놀리식 어플리케이션, 혹은 분산되어 있다고는 하지만 사실상 데이터와 로직이 얽혀있는 느슨하지 않은 SOA 등이 그렇다. 이런 환경에서는 작은 변화도 수많은 팀과 승인 절차를 거쳐야 하고, 하나 수정하면 예상치 못한 다른 부서 시스템이 오류나는 일이 발생한다. 조직 구조 역시 부서 간 결합도가 높아 서로 의존적인 프로젝트들이 발목을 잡는다. 이런 상황에서 탈피하려면 기술적 리팩토링뿐 아니라 조직 개편, 운영 프로세스 변화 등 큰 결단이 필요하다. 다행히 현대에는 클라우드 네이티브, DevOps 문화가 퍼지면서 많은 조직이 느슨한 결합 아키텍처 + 자율적인 팀 구조로 전환하는 추세다. 이는 단순한 기술 변경이 아니라 엔지니어링 생산성을 위한 필수 진화라 볼 수 있다.
* 정리: 결합도는 시스템 구성 요소들이 얼만큼 서로 엮여 있나를 나타내는 지표로, 소프트웨어 설계의 난이도를 좌우한다. 낮은 결합도를 추구하면 모듈 독립성이 높아져 변경 용이성과 재사용성이 향상된다. 그러나 지나치게 분리하면 복잡도가 다른 형태로 나타날 수 있으므로, 응집도를 유지하면서 적절히 결합도를 관리하는 것이 중요하다. 모던 소프트웨어 엔지니어링에서는 마이크로서비스, 이벤트 드리븐, DI, 인터페이스 설계 등 다양한 기법으로 결합도를 제어하며, 그 목표는 변화에 민첩하고 확장 가능한 시스템을 만드는 것이다.

4부. 소프트웨어 엔지니어를 위한 아이디어

14장. 실제 사례로 되짚어 본 소프트웨어 공학
* 소프트웨어 개발, 그 진실에 대하여: 이론과 원칙을 모두 적용하면 언제나 순탄할 것 같지만, 현실 프로젝트는 늘 예상치 못한 난관과 절충의 연속이다. 요구사항은 변하고, 완벽했던 설계에도 버그가 생긴다. 여기서 소프트웨어 공학의 가치는 빛난다. 공학 원칙은 문제가 발생하지 않게 하는 것뿐 아니라, 문제가 발생해도 효과적으로 대처할 수 있게 해주는 안전망을 제공한다. 실제 경험을 통해 “왜 테스트가 중요하고, 왜 자동화가 필요한지” 절감한 사례들을 살펴보자. 이는 앞서 배운 원칙들이 현장에서 어떻게 적용되는지 보여줄 것이다.
* 테스트 가능한 코드 사례 1: 한 금융 시스템 팀에서 복잡한 이자 계산 모듈을 개발했는데, 처음에는 단위 테스트 없이 수동 테스트로 검증했다. 시간이 지나 유지보수 인력이 바뀌자, 겁나서 코드를 못 고칠 지경이 됐다. 나중에 들어온 시니어 엔지니어가 해당 모듈을 리팩토링하여 함수별 단위 테스트를 촘촘히 작성했고, 정보 은닉을 철저히 하여 모듈 경계를 명확히 했다. 그 결과 새로운 요구사항(복리 계산 방식 변경)이 들어와도 테스트를 돌려가며 안정적으로 수정할 수 있었다. 이 사례는 **“테스트가 어려운 코드는 문제가 있다”** 는 교훈과 함께, 테스트가 가능해지면 리팩토링이 용이해져 결과적으로 코드 품질이 올라간다는 것을 보여준다.
* 시스템은 반드시 측정 가능해야 한다: 대규모 서비스 운영 사례에서 흔히 듣는 말이다. 예를 들어 어느 날 트래픽 폭주로 시스템이 느려졌는데, 정작 모니터링과 로깅이 미흡하여 원인을 못 찾는다면 엔지니어는 깜깜한 상태에서 추측만 하게 된다. 반면 잘 구축된 모니터링 시스템은 CPU, 메모리, 요청수, 오류율 등을 시각화해주고, 어느 모듈에서 병목이 생겼는지 데이터로 알려준다. 한 e커머스 회사는 모든 주요 기능에 대한 성능 지표와 비즈니스 지표(장바구니 추가율 등)를 실시간으로 수집한 덕분에, 문제 발생 시 신속히 근본 원인을 파악하고 대응할 수 있었다. 이는 경험주의와 피드백 원칙이 운영 단계에서도 똑같이 중요함을 일깨운다 – **“보이는 소프트웨어”** 를 만들어야 지속 개선이 가능하다.
* 테스트 가능한 코드 사례 2: 한 웹 서비스 팀은 레거시 코드베이스에 자동 테스트가 거의 없었다. 새로운 기능 추가 시 기존 것들이 종종 망가졌고, 이를 발견하는 건 QA나 사용자 몫이었다. 이를 개선하기 위해 팀장은 캠페인 식 리팩토링을 진행했다: 매주 시간이 날 때마다 특정 컴포넌트를 선택해 단위 테스트를 추가하고, 테스트하기 어렵게 설계된 부분은 구조를 개선했다. 예를 들어 글로벌 상태에 의존하던 함수들을 객체로 묶고 DI를 적용하여 상태를 주입받게 변경하고, I/O 코드와 로직 코드를 분리했다. 몇 개월에 걸친 노력 끝에 테스트 커버리지가 0%대에서 60%대로 상승했고, 배포 시 사고가 현저히 줄었다. 개발자들은 이제 부담 없이 리팩토링할 수 있게 되었고 속도도 빨라졌다. 이 사례는 **“빚을 갚듯 기술 부채(낮은 테스트 커버리지)를 갚아나가면 공학적 품질이 향상된다”** 는 사실을 잘 보여준다.
* 테스트: 시스템의 시작: 많은 초보 개발자는 개발 다 하고 마지막에 테스트한다고 생각하지만, 실제 뛰어난 팀은 테스트 작성으로 일을 시작한다. 요구사항을 테스트 시나리오로 풀어내면서 무엇을 만들지 명확히 정의하고, 개발 중간중간 돌려보며 바른 길로 가고 있는지 확인한다. 이러한 접근은 결국 개발의 전체 사이클에서 테스트가 중심에 있음을 뜻한다. CI 파이프라인에서 빌드보다 테스트가 오래 걸릴 정도로 수백, 수천 개의 케이스가 돌고, 이는 곧 시스템의 안전망이 된다. 한 금융업체는 규제가 엄격해 새로운 릴리스 전에 수만 개의 자동화 테스트를 통과해야만 배포를 승인하는 프로세스를 운영한다. 이처럼 테스트는 프로젝트의 마지막 체크리스트 항목이 아니라, 처음부터 끝까지 개발을 견인하는 엔진 역할을 한다.
* 배포: 시스템의 완성: “컴파일되었다고 코드가 완성된 게 아니다. 프로덕션에 안정적으로 돌아가야 끝난 것이다.” 모던 소프트웨어 엔지니어링에서는 배포(Deployment)를 개발 라이프사이클의 필수 단계로 포함시킨다. 그래서 CI 다음에는 CD(Continuous Deployment)까지 이어지는 것이다. 어떤 팀은 매일 수십 회 자동 배포가 이뤄지는데, 이는 배포를 사람 수동이 아닌 시스템이 하도록 엔지니어링한 덕분이다. 배포 자동화 스크립트, IaC(Infrastructure as Code), 컨테이너 기술 등을 활용해, 개발자가 코드를 커밋하면 짧은 시간 내에 프로덕션 반영까지 되게 한다. 배포 파이프라인에 장애 감지와 롤백 메커니즘도 넣어 문제가 생기면 자동 되돌리기까지 처리한다. 이러한 배포 자동화는 개발팀이 큰 변화에도 두려움 없이 시도해볼 수 있게 해주며, 결국 더 빠른 피드백 루프를 완성한다.
* 피드백의 속도: 더 나은 품질과 결과물을 위한 필수 요소: 앞서 여러 번 강조했듯, 피드백은 빠를수록 가치가 크다. 실무 예로, 어떤 모바일 앱 팀은 사용자 피드백 반영 주기를 기존 3개월에서 2주로 단축하자 앱 평점이 크게 올랐다고 한다. 사용자의 불만 사항이나 제안이 금세 다음 버전에 반영되니, 앱 품질이 개선되고 고객 만족도가 향상된 것이다. 또 다른 예로, A/B 테스트 플랫폼을 구축한 팀은 기능별 실험 결과(전환율 변화 등)를 며칠 내로 확인하여, 가설이 틀린 기능은 과감히 폐기하고 유효한 개선만 채택했다. 그 결과 개발 효율과 제품 품질이 동시에 상승했다. 결국 짧은 피드백 주기 = 고속 학습 주기이며, 이는 곧 품질과 가치를 높이는 지름길이다 ￼.
* 시스템의 전 과정에서 변수를 통제하자: 앞서 실험주의에서 변수 통제에 대해 이야기했는데, 운영 환경에서도 적용된다. 예를 들어 장애가 발생하면 한꺼번에 여러 변경을 롤백하지 말고 순차적으로 하나씩 롤백하면서 원인을 특정해야 한다. 또는 성능 튜닝 시도도 한 가지 설정씩 바꿔가며 효과를 측정해야 한다. 복잡한 시스템일수록 동시에 많은 일이 일어나기 때문에, 문제 분석을 쉽게 하려면 가급적 변동 요인을 줄이는 운영 습관이 중요하다. 카나리아 배포(일부 트래픽에만 새 버전 적용)도 비슷한 맥락인데, 전체에 영향 주지 않고 작은 통제 실험으로 시작함으로써 위험을 줄인다. 결국 개발부터 운영까지 **“무엇이 달라졌기에 결과가 달라졌는가”** 를 추적할 수 있게 하는 것이 공학적 관리의 핵심이며, 이를 위한 원칙이 변수 통제다.
* 지속적인 배포를 잊지 말자: 지속적 배포(Continuous Delivery/Deployment)는 현대 소프트웨어 엔지니어링의 총아(寵兒)라 할 만하다 ￼. 기술적으로 자동화된 배포와 테스트가 받쳐줘야 가능하지만, 문화적으로는 **“항상 배포 가능 상태로 작업”** 하는 습관이 중요하다. 기능이 완벽하지 않아도 뒤에 숨겨놓고(main 브랜치에 머지하지만 feature toggle로 비활성) 점진적으로 개발하거나, 작은 개선이라도 나오면 바로 배포하여 피드백을 받는다. 이렇게 하면 위험이 분산되고, 배포를 특별한 이벤트가 아니라 일상으로 만듦으로써 팀 스트레스도 준다. 실제로 구글이나 아마존 등의 엔지니어는 “배포”를 긴장되는 일이 아니라 하루에도 몇 번씩 하는 당연한 일로 받아들인다. 이는 시스템이 언제나 업데이트될 수 있음을 의미하고, 따라서 코드도 항상 정돈되고 테스트된 상태로 유지하려는 노력이 뒤따른다. 지속적 배포는 앞서 말한 대부분의 원칙(반복, 피드백, 점진적 변화 등)을 아우르는 실천이기도 하다.
* 소프트웨어에서 고려해야 할 질문들: 마지막으로, 실제 사례들을 통해 떠오른 자문자답 리스트를 개발자들은 프로젝트마다 가져볼 필요가 있다. 예를 들면:
* “우리 시스템의 가장 복잡한 부분은 어디이고, 이를 어떻게 관리하고 있는가?” – (복잡성 방치 X, 모듈화/추상화 적용 O)
* “문제가 생기면 어떻게 알 수 있으며, 얼마나 빨리 대응할 수 있는가?” – (모니터링/로그, 알람 체계, On-call 절차 등)
* “팀원 누구라도 새로운 코드를 안전하게 배포할 수 있는가?” – (자동 테스트/배포, 코드리뷰 등으로 배포 안정성 확보)
* “기술 부채를 관리하고 있는가?” – (정기적 리팩토링, 개선 항목 백로그 관리)
* “우리 시스템은 확장/변경에 얼마나 열려 있는가?” – (새 기능 추가 시 얼마나 영향 범위가 좁은지, 아키텍처 여유는 있는지)
이러한 질문들은 곧 우리가 실천해온 소프트웨어 공학 원칙들의 검증 체크리스트라 할 수 있다.
* 정리: 실제 사례들을 통해 배운 것은, 원칙은 현장에서 구체적 실천으로 이어져야 효과가 있다는 점이다. 자동화된 테스트 한 줄, 모니터링 대시보드 하나 같은 작은 실천들이 모여 공학적 품질 향상을 만들어낸다. 또한 문제가 드러났을 때 공학 원칙으로 돌아가 해법을 찾는 것이 중요하다. 모던 소프트웨어 엔지니어는 “문제가 생기면 근본 원인을 찾아 프로세스를 개선”하는 자세로 임해야 하며, 이는 곧 지속적 개선(Continuous Improvement) 문화와도 상통한다. 결국 사례의 교훈은: 원칙들을 머리로만 아는 것을 넘어, 팀과 시스템에 체화시킬 때 진정한 가치가 발현된다는 것이다.

15장. 모던 소프트웨어 엔지니어가 되려면
* 팀이나 조직도 복잡성의 관리 대상임을 잊지 말자: 소프트웨어 공학 원칙은 코드에만 국한되지 않는다. 잘게 나뉜 마이크로서비스 아키텍처가 효과적이려면 그에 맞게 조직 구조도 소규모 자율팀들로 나뉘어야 한다. 큰 팀 하나에 모든 것이 얽혀 있으면 인적 결합도가 높아 협업이 어려워진다. 따라서 Conway의 법칙을 의식하여, 조직을 설계할 때 시스템 모듈 경계와 팀 책임을 정렬시키는 것이 좋다. 또한 **지식의 버스 팩터(bus factor)** 를 높이기 위해 문서화, 페어프로그래밍, 코드리뷰 등으로 개인에게 과도하게 의존하지 않도록 한다. 복잡한 프로젝트일수록 프로젝트 관리, 커뮤니케이션 구조 등 소프트웨어 개발을 둘러싼 사람과 프로세스의 영역도 엔지니어링 마인드로 최적화해야 한다. 결국 조직 전체를 하나의 시스템으로 보고 지속 개선하는 자세가 필요하다.
* 디지털적으로 파괴적인 조직을 추구하자: “Digital disruptive”란 혁신적으로 기존 방식을 깨고 나아간다는 의미다. 모던 소프트웨어 엔지니어는 자기 조직(혹은 자기 자신)이 구태의연한 비효율에 안주하지 않고 새로운 기술과 방법을 과감히 시도할 수 있어야 한다. 예를 들어 수작업 배포를 자동화하거나, 온프레미스 시스템을 클라우드로 옮기는 변화가 필요할 때 이를 주도하는 자세다. 때론 기존의 성공 방정식도 시대에 뒤떨어질 수 있으므로, 성공을 방해하는 요소라면 과감히 혁신하는 용기가 필요하다. 엔지니어 개인도 마찬가지로, 익숙한 기술만 고집하면 성장 정체에 빠진다. 학습의 전문가로서 새로운 언어, 새로운 아키텍처를 꾸준히 접하고 배우면서 자기 혁신을 해야 한다. 이러한 파괴적 혁신 마인드가 결과적으로 조직과 개인을 한 단계 도약시킨다.
* 결과 vs 메커니즘, 무엇이 더 중요할까: 흔히 *성과(Outcome)*와 *활동(Activity)*를 구분한다. 소프트웨어 엔지니어링에서도 마찬가지인데, 어떤 프로세스를 따르는 것 자체가 목적이 되어선 안 되고, 그를 통해 얻는 결과가 중요하다. 예컨대 “우리 애자일 스프린트 철저히 지켰어”가 중요한 게 아니라, 정말로 고객에게 가치가 빨리 전달되고 있는지가 핵심이다. 테스트 커버리지 100%여도 버그투성이면 의미가 없다. 따라서 메커니즘(과정)은 어디까지나 결과를 좋게 내기 위한 수단으로서 유연하게 활용해야 한다. 엔지니어는 **성공 지표(예: 시스템 가동시간, 사용자 수, 성능 수치 등)** 를 염두에 두고 일해야 하며, 상황이 바뀌면 프로세스도 조정할 수 있어야 한다. 결과 중심으로 사고하면 불필요한 형식주의에 빠지지 않게 되고, 진짜 가치를 창출하는데 집중할 수 있다.
* 소프트웨어 공학 원칙은 머신러닝 시스템에도 유효하다: 최근 많은 개발이 머신러닝(ML)을 포함하고 있다. ML에서는 데이터 수집, 모델 학습 등 특유의 파이프라인이 있지만, 결국 그것도 소프트웨어 시스템이다. 따라서 지금까지 다룬 원칙들이 똑같이 적용된다. 예를 들어 재현 가능한 실험(실험주의) – 머신러닝 모델도 실험 설정(하이퍼파라미터)을 관리하고 결과를 측정해야 한다. 모듈성 – 데이터 전처리, 모델 학습, 예측 서빙을 모듈화하면 파이프라인 변경이 수월해진다. 피드백 루프 – 모델의 예측 오류율 등을 모니터링하고 주기적으로 재학습(Continuous Training)하는 피드백이 필요하다. 이처럼 ML도 하나의 소프트웨어니까, 데이터와 모델이라는 새로운 개념을 다룰 뿐 공학적 관리가 본질이다. 실제로 ML 시스템 구축 가이드들을 보면 버전 관리, 테스트(데이터 검증), 모니터링 등 일반 소프트웨어 엔지니어링과 겹치는 부분이 많다. 결론적으로, AI 시대에도 기본기(공학 원리)가 중요하다는 것을 명심해야 한다.
* 모던 소프트웨어 엔지니어링의 핵심 아이디어: 끝으로, 현대 소프트웨어 개발을 관통하는 아이디어들을 간단히 정리하면 다음과 같다.
* 작게 나누고 빨리 돌려라 – 반복, 피드백, 점진적 개선을 통해 리스크를 통제하고 빠르게 진화한다 ￼.
* 근거 기반으로 결정하라 – 측정, 실험, 데이터에 기반해 객관적으로 판단한다 ￼.
* 복잡성은 적극적으로 다뤄라 – 방치하지 말고 모듈화, 추상화, 자동화로 복잡성을 관리한다 ￼.
* 품질은 내재된 것이다 – 품질을 나중에 붙이는게 아니라 (테스트/디버그), 처음부터 내재화시킨다. 예: 클린코드, TDD, CI/CD 등으로 개발 과정 속에 품질 확보.
* 끊임없이 배우고 개선하라 – 기술도 방법론도 계속 변하므로, 학습과 적응이 궁극의 무기이다. 특히 실패로부터 배우는 조직 문화, 지속적 개선(Kaizen) 정신이 중요하다.
* 정리: 모던 소프트웨어 엔지니어란, 과학자처럼 호기심을 갖고 실험하고, 엔지니어처럼 체계화하고, 장인처럼 열정을 갖고 품질을 추구하는 사람이다. 오늘날 우리가 논의한 원칙들(반복, 피드백, 원리들)은 결국 “더 나은 소프트웨어를 더 빠르게(Better Software Faster)” 만들기 위함이며 ￼ ￼, 이를 통해 사용자와 사회에 가치를 전달하는 것이 궁극적 목표다. 비전공자 1학년이라도 이 핵심 개념들을 이해한다면, 앞으로 어떤 역할이든 소프트웨어와 관련된 일을 할 때 큰 그림을 보고 올바른 판단을 하는 데 도움 될 것이다. 소프트웨어 엔지니어링은 계속 발전중인 분야이니만큼, 여러분도 앞으로 배움과 경험을 통해 이 원칙들을 자기 것으로 만들고 현장에서 응용하길 바란다. 이는 단지 개발의 효율을 높이는 것을 넘어, 더 창의적이고 신뢰성 있는 디지털 세상을 만드는 밑거름이 될 것이다.